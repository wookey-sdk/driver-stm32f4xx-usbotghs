[kernel] Parsing usbctrl.c (with preprocessing)
[kernel] Parsing usbctrl_descriptors.c (with preprocessing)
[kernel] Parsing usbctrl_handlers.c (with preprocessing)
[kernel] Parsing usbctrl_requests.c (with preprocessing)
[kernel] Parsing usbctrl_state.c (with preprocessing)
[kernel] Parsing usbotghs_frama.c (with preprocessing)
[kernel] usbotghs_frama.c:698: Warning: 
  Ignoring un-named typedef that does not introduce a struct or enumeration type
[kernel] usbotghs_frama.c:763: Warning: 
  Ignoring un-named typedef that does not introduce a struct or enumeration type
[variadic] Warning: Unable to locate ACSL predicate valid_read_string which should be in the Frama-C LibC. Correct specifications can't be generated.
[variadic] Warning: Unable to locate global __fc_stdout which should be in the Frama-C LibC. Correct specifications can't be generated.
[variadic] usbotghs_frama.c:1079: Warning: 
  Incorrect type for argument 3. The argument will be cast from usbotghs_ep_dir_t (unsigned int) to int.
[variadic] usbotghs_frama.c:1122: Warning: 
  Incorrect type for argument 3. The argument will be cast from usbotghs_ep_dir_t (unsigned int) to int.
/* Generated by Frama-C */
#include "__fc_builtin.h"
typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef uint32_t physaddr_t;
typedef unsigned int size_t;
enum __anonenum_bool_1 {
    false = 0,
    true = 1
};
typedef enum __anonenum_bool_1 bool;
enum __anonenum_mbed_error_t_3 {
    MBED_ERROR_NONE = 0,
    MBED_ERROR_NOMEM = 1,
    MBED_ERROR_NOSTORAGE = 2,
    MBED_ERROR_NOBACKEND = 3,
    MBED_ERROR_INVCREDENCIALS = 4,
    MBED_ERROR_UNSUPORTED_CMD = 5,
    MBED_ERROR_INVSTATE = 6,
    MBED_ERROR_NOTREADY = 7,
    MBED_ERROR_BUSY = 8,
    MBED_ERROR_DENIED = 9,
    MBED_ERROR_UNKNOWN = 10,
    MBED_ERROR_INVPARAM = 11,
    MBED_ERROR_WRERROR = 12,
    MBED_ERROR_RDERROR = 13,
    MBED_ERROR_INITFAIL = 14,
    MBED_ERROR_TOOBIG = 15,
    MBED_ERROR_NOTFOUND = 16
};
typedef enum __anonenum_mbed_error_t_3 mbed_error_t;
enum __anonenum_e_init_type_7 {
    INIT_DEVACCESS = 0,
    INIT_DMA = 1,
    INIT_DMA_SHM = 2,
    INIT_GETTASKID = 3,
    INIT_DONE = 4,
    INIT_MAX = 5
};
enum __anonenum_e_cfg_type_9 {
    CFG_GPIO_SET = 0,
    CFG_GPIO_GET = 1,
    CFG_GPIO_UNLOCK_EXTI = 2,
    CFG_DMA_RECONF = 3,
    CFG_DMA_RELOAD = 4,
    CFG_DMA_DISABLE = 5,
    CFG_DEV_MAP = 6,
    CFG_DEV_UNMAP = 7,
    CFG_DEV_RELEASE = 8
};
enum __anonenum_e_syscall_ret_12 {
    SYS_E_DONE = 0,
    SYS_E_INVAL = 1,
    SYS_E_DENIED = 2,
    SYS_E_BUSY = 3,
    SYS_E_MAX = 4
};
typedef enum __anonenum_e_syscall_ret_12 e_syscall_ret;
enum __anonenum_gpio_af_t_13 {
    GPIO_AF_AF0 = 0x0,
    GPIO_AF_AF1 = 0x1,
    GPIO_AF_AF2 = 0x2,
    GPIO_AF_AF3 = 0x3,
    GPIO_AF_AF4 = 0x4,
    GPIO_AF_AF5 = 0x5,
    GPIO_AF_AF6 = 0x6,
    GPIO_AF_AF7 = 0x7,
    GPIO_AF_AF8 = 0x8,
    GPIO_AF_AF9 = 0x9,
    GPIO_AF_AF10 = 0xa,
    GPIO_AF_AF11 = 0xb,
    GPIO_AF_AF12 = 0xc,
    GPIO_AF_AF13 = 0xd,
    GPIO_AF_AF14 = 0xe,
    GPIO_AF_AF15 = 0xf
};
enum __anonenum_gpio_pupd_t_14 {
    GPIO_NOPULL = 0,
    GPIO_PULLUP = 1,
    GPIO_PULLDOWN = 2
};
typedef enum __anonenum_gpio_pupd_t_14 gpio_pupd_t;
enum __anonenum_gpio_mode_t_15 {
    GPIO_PIN_INPUT_MODE = 0,
    GPIO_PIN_OUTPUT_MODE = 1,
    GPIO_PIN_ALTERNATE_MODE = 2,
    GPIO_PIN_ANALOG_MODE = 3
};
typedef enum __anonenum_gpio_mode_t_15 gpio_mode_t;
enum __anonenum_gpio_speed_t_16 {
    GPIO_PIN_LOW_SPEED = 0,
    GPIO_PIN_MEDIUM_SPEED = 1,
    GPIO_PIN_HIGH_SPEED = 2,
    GPIO_PIN_VERY_HIGH_SPEED = 3
};
typedef enum __anonenum_gpio_speed_t_16 gpio_speed_t;
enum __anonenum_gpio_type_t_17 {
    GPIO_PIN_OTYPER_PP = 0,
    GPIO_PIN_OTYPER_OD = 1
};
typedef enum __anonenum_gpio_type_t_17 gpio_type_t;
enum __anonenum_gpio_mask_t_18 {
    GPIO_MASK_SET_MODE = 0b000000001,
    GPIO_MASK_SET_TYPE = 0b000000010,
    GPIO_MASK_SET_SPEED = 0b000000100,
    GPIO_MASK_SET_PUPD = 0b000001000,
    GPIO_MASK_SET_BSR_R = 0b000010000,
    GPIO_MASK_SET_BSR_S = 0b000100000,
    GPIO_MASK_SET_LCK = 0b001000000,
    GPIO_MASK_SET_AFR = 0b010000000,
    GPIO_MASK_SET_EXTI = 0b100000000,
    GPIO_MASK_SET_ALL = 0b111111111
};
typedef enum __anonenum_gpio_mask_t_18 gpio_mask_t;
enum __anonenum_gpio_exti_trigger_t_19 {
    GPIO_EXTI_TRIGGER_NONE = 0,
    GPIO_EXTI_TRIGGER_RISE = 1,
    GPIO_EXTI_TRIGGER_FALL = 2,
    GPIO_EXTI_TRIGGER_BOTH = 3
};
typedef enum __anonenum_gpio_exti_trigger_t_19 gpio_exti_trigger_t;
enum __anonenum_gpio_exti_lock_t_20 {
    GPIO_EXTI_UNLOCKED = 0,
    GPIO_EXTI_LOCKED = 1
};
typedef enum __anonenum_gpio_exti_lock_t_20 gpio_exti_lock_t;
struct __anonstruct_22 {
   unsigned char pin : 4 ;
   unsigned char port : 4 ;
};
union __anonunion_gpioref_t_21 {
   struct __anonstruct_22 __anonCompField1 ;
   unsigned char val ;
};
typedef union __anonunion_gpioref_t_21 gpioref_t;
struct __anonstruct_dev_gpio_info_t_23 {
   gpio_mask_t mask ;
   gpioref_t kref ;
   gpio_mode_t mode ;
   gpio_pupd_t pupd ;
   gpio_type_t type ;
   gpio_speed_t speed ;
   uint32_t afr ;
   uint32_t bsr_r ;
   uint32_t bsr_s ;
   uint32_t lck ;
   gpio_exti_trigger_t exti_trigger ;
   gpio_exti_lock_t exti_lock ;
   void (*exti_handler)(uint8_t irq, uint32_t status, uint32_t data) ;
};
typedef struct __anonstruct_dev_gpio_info_t_23 dev_gpio_info_t;
enum __anonenum_dev_irq_ph_action_t_24 {
    IRQ_PH_NIL = 0,
    IRQ_PH_READ = 1,
    IRQ_PH_WRITE = 2,
    IRQ_PH_AND = 3,
    IRQ_PH_MASK = 4
};
typedef enum __anonenum_dev_irq_ph_action_t_24 dev_irq_ph_action_t;
struct __anonstruct_dev_irq_ph_read_t_25 {
   uint32_t offset ;
   uint32_t value ;
};
typedef struct __anonstruct_dev_irq_ph_read_t_25 dev_irq_ph_read_t;
struct __anonstruct_dev_irq_ph_write_t_26 {
   uint32_t offset ;
   uint32_t value ;
   uint32_t mask ;
};
typedef struct __anonstruct_dev_irq_ph_write_t_26 dev_irq_ph_write_t;
struct __anonstruct_dev_irq_ph_and_t_27 {
   uint32_t offset_dest ;
   uint32_t offset_src ;
   uint32_t mask ;
   uint8_t mode ;
};
typedef struct __anonstruct_dev_irq_ph_and_t_27 dev_irq_ph_and_t;
struct __anonstruct_dev_irq_ph_mask_t_28 {
   uint32_t offset_dest ;
   uint32_t offset_src ;
   uint32_t offset_mask ;
   uint8_t mode ;
};
typedef struct __anonstruct_dev_irq_ph_mask_t_28 dev_irq_ph_mask_t;
union __anonunion_30 {
   dev_irq_ph_read_t read ;
   dev_irq_ph_write_t write ;
   dev_irq_ph_and_t and ;
   dev_irq_ph_mask_t mask ;
};
struct __anonstruct_dev_irq_ph_instruction_t_29 {
   dev_irq_ph_action_t instr ;
   union __anonunion_30 __anonCompField2 ;
};
typedef struct __anonstruct_dev_irq_ph_instruction_t_29 dev_irq_ph_instruction_t;
struct __anonstruct_dev_irq_ph_t_31 {
   dev_irq_ph_instruction_t action[10] ;
   uint32_t status ;
   uint32_t data ;
};
typedef struct __anonstruct_dev_irq_ph_t_31 dev_irq_ph_t;
enum __anonenum_dev_irq_isr_scheduling_t_32 {
    IRQ_ISR_STANDARD = 0,
    IRQ_ISR_FORCE_MAINTHREAD = 1,
    IRQ_ISR_WITHOUT_MAINTHREAD = 2
};
typedef enum __anonenum_dev_irq_isr_scheduling_t_32 dev_irq_isr_scheduling_t;
struct __anonstruct_dev_irq_info_t_33 {
   void (*handler)(uint8_t irq, uint32_t status, uint32_t data) ;
   uint8_t irq ;
   dev_irq_isr_scheduling_t mode ;
   dev_irq_ph_t posthook ;
};
typedef struct __anonstruct_dev_irq_info_t_33 dev_irq_info_t;
enum __anonenum_dev_map_mode_t_34 {
    DEV_MAP_AUTO = 0,
    DEV_MAP_VOLUNTARY = 1
};
typedef enum __anonenum_dev_map_mode_t_34 dev_map_mode_t;
struct __anonstruct_device_t_35 {
   char name[16] ;
   physaddr_t address ;
   uint32_t size ;
   uint8_t irq_num ;
   uint8_t gpio_num ;
   dev_map_mode_t map_mode ;
   dev_irq_info_t irqs[4] ;
   dev_gpio_info_t gpios[16] ;
};
typedef struct __anonstruct_device_t_35 device_t;
struct user_driver_device_gpio_infos {
   uint8_t port ;
   uint8_t pin ;
};
struct user_driver_device_infos {
   physaddr_t address ;
   uint32_t size ;
   uint32_t id ;
   struct user_driver_device_gpio_infos gpios[14] ;
};
enum __anonenum_usb_backend_drv_port_speed_t_49 {
    USB_BACKEND_DRV_PORT_LOWSPEED = 0,
    USB_BACKEND_DRV_PORT_FULLSPEED = 1,
    USB_BACKEND_DRV_PORT_HIGHSPEED = 2
};
typedef enum __anonenum_usb_backend_drv_port_speed_t_49 usb_backend_drv_port_speed_t;
enum __anonenum_usb_backend_drv_ep_nb_t_50 {
    EP0 = 0,
    EP1 = 1,
    EP2 = 2,
    EP3 = 3,
    EP4 = 4,
    EP5 = 5,
    EP6 = 6,
    EP7 = 7,
    EP8 = 8
};
enum __anonenum_usb_backend_drv_mode_t_51 {
    USB_BACKEND_DRV_MODE_HOST = 0,
    USB_BACKEND_DRV_MODE_DEVICE = 1
};
typedef enum __anonenum_usb_backend_drv_mode_t_51 usb_backend_drv_mode_t;
enum __anonenum_usb_backend_drv_ep_dir_t_52 {
    USB_BACKEND_DRV_EP_DIR_IN = 0,
    USB_BACKEND_DRV_EP_DIR_OUT = 1
};
typedef enum __anonenum_usb_backend_drv_ep_dir_t_52 usb_backend_drv_ep_dir_t;
enum __anonenum_usb_backend_drv_ep_type_t_53 {
    USB_BACKEND_DRV_EP_TYPE_CONTROL = 0,
    USB_BACKEND_DRV_EP_TYPE_ISOCHRONOUS = 1,
    USB_BACKEND_DRV_EP_TYPE_BULK = 2,
    USB_BACKEND_DRV_EP_TYPE_INT = 3
};
typedef enum __anonenum_usb_backend_drv_ep_type_t_53 usb_backend_drv_ep_type_t;
enum __anonenum_usb_backend_drv_ep_state_t_54 {
    USB_BACKEND_DRV_EP_STATE_IDLE = 0,
    USB_BACKEND_DRV_EP_STATE_SETUP_WIP = 1,
    USB_BACKEND_DRV_EP_STATE_SETUP = 2,
    USB_BACKEND_DRV_EP_STATE_STATUS = 3,
    USB_BACKEND_DRV_EP_STATE_STALL = 4,
    USB_BACKEND_DRV_EP_STATE_DATA_IN_WIP = 5,
    USB_BACKEND_DRV_EP_STATE_DATA_in = 6,
    USB_BACKEND_DRV_EP_STATE_DATA_OUT_WIP = 7,
    USB_BACKEND_DRV_EP_STATE_DATA_OUT = 8,
    USB_BACKEND_DRV_EP_STATE_INVALID = 9
};
enum __anonenum_usb_backend_drv_epx_mpsize_t_55 {
    USB_BACKEND_DRV_EPx_MPSIZE_64BYTES = 64,
    USB_BACKEND_DRV_EPx_MPSIZE_128BYTES = 128,
    USB_BACKEND_DRV_EPx_MPSIZE_512BYTES = 512,
    USB_BACKEND_DRV_EPx_MPSIZE_1024BYTES = 1024
};
typedef enum __anonenum_usb_backend_drv_epx_mpsize_t_55 usb_backend_drv_epx_mpsize_t;
enum __anonenum_usb_backend_drv_ep_toggle_t_56 {
    USB_BACKEND_EP_EVENFRAME = 0,
    USB_BACKEND_EP_ODDFRAME = 1
};
typedef enum __anonenum_usb_backend_drv_ep_toggle_t_56 usb_backend_drv_ep_toggle_t;
enum __anonenum_usbotghs_port_speed_t_57 {
    USBOTG_HS_PORT_LOWSPEED = 0,
    USBOTG_HS_PORT_FULLSPEED = 1,
    USBOTG_HS_PORT_HIGHSPEED = 2
};
typedef enum __anonenum_usbotghs_port_speed_t_57 usbotghs_port_speed_t;
enum __anonenum_usbotghs_dev_mode_t_58 {
    USBOTGHS_MODE_HOST = 0,
    USBOTGHS_MODE_DEVICE = 1
};
typedef enum __anonenum_usbotghs_dev_mode_t_58 usbotghs_dev_mode_t;
enum __anonenum_usbotghs_epx_mpsize_t_61 {
    USBOTG_HS_EPx_MPSIZE_64BYTES = 64,
    USBOTG_HS_EPx_MPSIZE_128BYTES = 128,
    USBOTG_HS_EPx_MPSIZE_512BYTES = 512,
    USBOTG_HS_EPx_MPSIZE_1024BYTES = 1024
};
typedef enum __anonenum_usbotghs_epx_mpsize_t_61 usbotghs_epx_mpsize_t;
enum __anonenum_usbotghs_ep_toggle_t_62 {
    USB_HS_DXEPCTL_SD0PID_SEVNFRM = 0,
    USB_HS_DXEPCTL_SD1PID_SODDFRM = 1
};
typedef enum __anonenum_usbotghs_ep_toggle_t_62 usbotghs_ep_toggle_t;
enum __anonenum_usbotghs_ep_type_t_63 {
    USBOTG_HS_EP_TYPE_CONTROL = 0,
    USBOTG_HS_EP_TYPE_ISOCHRONOUS = 1,
    USBOTG_HS_EP_TYPE_BULK = 2,
    USBOTG_HS_EP_TYPE_INT = 3
};
typedef enum __anonenum_usbotghs_ep_type_t_63 usbotghs_ep_type_t;
enum __anonenum_usbotghs_ep_state_t_64 {
    USBOTG_HS_EP_STATE_IDLE = 0,
    USBOTG_HS_EP_STATE_SETUP_WIP = 1,
    USBOTG_HS_EP_STATE_SETUP = 2,
    USBOTG_HS_EP_STATE_STATUS = 3,
    USBOTG_HS_EP_STATE_STALL = 4,
    USBOTG_HS_EP_STATE_DATA_IN_WIP = 5,
    USBOTG_HS_EP_STATE_DATA_IN = 6,
    USBOTG_HS_EP_STATE_DATA_OUT_WIP = 7,
    USBOTG_HS_EP_STATE_DATA_OUT = 8,
    USBOTG_HS_EP_STATE_INVALID = 9
};
typedef enum __anonenum_usbotghs_ep_state_t_64 usbotghs_ep_state_t;
enum __anonenum_usbotghs_ep_dir_t_65 {
    USBOTG_HS_EP_DIR_IN = 0,
    USBOTG_HS_EP_DIR_OUT = 1
};
typedef enum __anonenum_usbotghs_ep_dir_t_65 usbotghs_ep_dir_t;
enum __anonenum_usbotghs_speed_t_66 {
    USBOTG_HS_SPEED_LS = 0,
    USBOTG_HS_SPEED_FS = 1,
    USBOTG_HS_SPEED_HS = 2
};
typedef enum __anonenum_usbotghs_speed_t_66 usbotghs_speed_t;
struct __anonstruct_usbotghs_ep_t_67 {
   uint8_t id ;
   bool configured ;
   uint16_t mpsize ;
   usbotghs_ep_type_t type ;
   usbotghs_ep_state_t volatile state ;
   usbotghs_ep_dir_t volatile dir ;
   mbed_error_t (*handler)(uint32_t dev_id, uint32_t size, uint8_t ep) ;
   uint8_t volatile *fifo ;
   uint32_t volatile fifo_idx ;
   uint32_t volatile fifo_size ;
   bool volatile fifo_lck ;
   bool volatile core_txfifo_empty ;
};
typedef struct __anonstruct_usbotghs_ep_t_67 usbotghs_ep_t;
struct __anonstruct_usbotghs_context_t_68 {
   device_t dev ;
   int dev_desc ;
   usbotghs_dev_mode_t mode ;
   bool gonak_req ;
   bool gonak_active ;
   uint16_t fifo_idx ;
   usbotghs_ep_t in_eps[8] ;
   usbotghs_ep_t out_eps[3] ;
   usbotghs_speed_t volatile speed ;
};
typedef struct __anonstruct_usbotghs_context_t_68 usbotghs_context_t;
enum __anonenum_usb_class_t_69 {
    USB_CLASS_UNSPECIFIED = 0x00,
    USB_CLASS_AUDIO = 0x01,
    USB_CLASS_CDC_CTRL = 0x02,
    USB_CLASS_HID = 0x03,
    USB_CLASS_RESERVED1 = 0x04,
    USB_CLASS_PID = 0x05,
    USB_CLASS_PTP_MTP = 0x06,
    USB_CLASS_PRINTER = 0x07,
    USB_CLASS_MSC_UMS = 0x08,
    USB_CLASS_HUB = 0x09,
    USB_CLASS_CDC_DATA = 0x0a,
    USB_CLASS_CCID = 0x0b,
    USB_CLASS_RESERVED2 = 0x0c,
    USB_CLASS_CSEC = 0x0d,
    USB_CLASS_VIDEO = 0x0e,
    USB_CLASS_PHDC = 0x0f,
    USB_CLASS_AV = 0x10,
    USB_CLASS_BILLBOARD = 0x11,
    USB_CLASS_DIAG = 0xDC,
    USB_CLASS_WIRELESS = 0xE0,
    USB_CLASS_MISC = 0xEF,
    USB_CLASS_DFU = 0xFE,
    USB_CLASS_VSPECIFIC = 0xFF
};
typedef enum __anonenum_usb_class_t_69 usb_class_t;
enum __anonenum_usb_ep_type_t_70 {
    USB_EP_TYPE_CONTROL = 0x00,
    USB_EP_TYPE_ISOCHRONOUS = 0x01,
    USB_EP_TYPE_BULK = 0x02,
    USB_EP_TYPE_INTERRUPT = 0x03
};
typedef enum __anonenum_usb_ep_type_t_70 usb_ep_type_t;
enum __anonenum_usb_ep_dir_t_71 {
    USB_EP_DIR_OUT = 0,
    USB_EP_DIR_IN = 1
};
typedef enum __anonenum_usb_ep_dir_t_71 usb_ep_dir_t;
enum __anonenum_usb_ep_attr_t_72 {
    USB_EP_ATTR_NO_SYNC = 0x0,
    USB_EP_ATTR_ASYNC = 0x1,
    USB_EP_ATTR_ADAPTATIVE = 0x2,
    USB_EP_ATTR_SYNC = 0x3
};
typedef enum __anonenum_usb_ep_attr_t_72 usb_ep_attr_t;
enum __anonenum_usb_ep_usage_t_73 {
    USB_EP_USAGE_DATA = 0x0,
    USB_EP_USAGE_FEEDBACK = 0x1,
    USB_EP_USAGE_IMPLICIT_FEEDBACK = 0x2
};
typedef enum __anonenum_usb_ep_usage_t_73 usb_ep_usage_t;
struct __anonstruct_usb_ep_infos_t_74 {
   usb_ep_type_t type ;
   usb_ep_dir_t dir ;
   usb_ep_attr_t attr ;
   usb_ep_usage_t usage ;
   uint16_t pkt_maxsize ;
   mbed_error_t (*handler)(uint32_t dev_id, uint32_t size, uint8_t ep_id) ;
   uint8_t ep_num ;
   uint8_t poll_interval ;
   bool configured ;
};
typedef struct __anonstruct_usb_ep_infos_t_74 usb_ep_infos_t;
struct __anonstruct_usbctrl_setup_pkt_t_75 {
   uint8_t bmRequestType ;
   uint8_t bRequest ;
   uint16_t wValue ;
   uint16_t wIndex ;
   uint16_t wLength ;
} __attribute__((__packed__));
typedef struct __anonstruct_usbctrl_setup_pkt_t_75 usbctrl_setup_pkt_t;
struct __anonstruct_usbctrl_interface_t_76 {
   uint8_t id ;
   usb_class_t usb_class ;
   uint8_t usb_subclass ;
   uint8_t usb_protocol ;
   bool dedicated ;
   mbed_error_t (*rqst_handler)(uint32_t usbdci_handler,
                                usbctrl_setup_pkt_t *inpkt) ;
   mbed_error_t (*class_desc_handler)(uint8_t iface_id, uint8_t *buf,
                                      uint32_t *desc_size,
                                      uint32_t usbdci_handler) ;
   uint8_t usb_ep_number ;
   usb_ep_infos_t eps[8] ;
};
typedef struct __anonstruct_usbctrl_interface_t_76 usbctrl_interface_t;
struct __anonstruct_usbctrl_configuration_t_77 {
   uint8_t first_free_epid ;
   uint8_t interface_num ;
   usbctrl_interface_t interfaces[4] ;
};
typedef struct __anonstruct_usbctrl_configuration_t_77 usbctrl_configuration_t;
enum __anonenum_ctrl_plane_rx_fifo_state_t_78 {
    USB_CTRL_RCV_FIFO_SATE_NOSTORAGE = 0,
    USB_CTRL_RCV_FIFO_SATE_FREE = 1,
    USB_CTRL_RCV_FIFO_SATE_BUSY = 2,
    USB_CTRL_RCV_FIFO_SATE_READY = 3
};
struct usbctrl_context {
   uint32_t dev_id ;
   uint16_t address ;
   uint8_t num_cfg ;
   uint8_t curr_cfg ;
   usbctrl_configuration_t cfg[2] ;
   uint8_t state ;
   uint8_t ctrl_fifo[128] ;
   bool ctrl_fifo_state ;
   bool volatile ctrl_req_processing ;
};
typedef struct usbctrl_context usbctrl_context_t;
enum __anonenum_usbctrl_request_code_t_79 {
    USB_REQ_GET_STATUS = 0x0,
    USB_REQ_CLEAR_FEATURE = 0x1,
    USB_REQ_FUTURE1 = 0x2,
    USB_REQ_SET_FEATURE = 0x3,
    USB_REQ_FUTURE2 = 0x4,
    USB_REQ_SET_ADDRESS = 0x5,
    USB_REQ_GET_DESCRIPTOR = 0x6,
    USB_REQ_SET_DESCRIPTOR = 0x7,
    USB_REQ_GET_CONFIGURATION = 0x8,
    USB_REQ_SET_CONFIGURATION = 0x9,
    USB_REQ_GET_INTERFACE = 0xa,
    USB_REQ_SET_INTERFACE = 0xb,
    USB_REQ_SYNCH_FRAME = 0xc
};
typedef enum __anonenum_usbctrl_request_code_t_79 usbctrl_request_code_t;
enum __anonenum_usbctrl_descriptor_type_t_80 {
    USB_DESC_DEVICE = 0x1,
    USB_DESC_CONFIGURATION = 0x2,
    USB_DESC_STRING = 0x3,
    USB_DESC_INTERFACE = 0x4,
    USB_DESC_ENDPOINT = 0x5,
    USB_DESC_DEV_QUALIFIER = 0x6,
    USB_DESC_OTHER_SPEED_CFG = 0x7,
    USB_DESC_IFACE_POWER = 0x8
};
typedef enum __anonenum_usbctrl_descriptor_type_t_80 usbctrl_descriptor_type_t;
enum __anonenum_usb_device_state_t_82 {
    USB_DEVICE_STATE_ATTACHED = 0,
    USB_DEVICE_STATE_POWERED = 1,
    USB_DEVICE_STATE_SUSPENDED_POWER = 2,
    USB_DEVICE_STATE_SUSPENDED_DEFAULT = 3,
    USB_DEVICE_STATE_SUSPENDED_ADDRESS = 4,
    USB_DEVICE_STATE_SUSPENDED_CONFIGURED = 5,
    USB_DEVICE_STATE_DEFAULT = 6,
    USB_DEVICE_STATE_ADDRESS = 7,
    USB_DEVICE_STATE_CONFIGURED = 8,
    USB_DEVICE_STATE_INVALID = 9
};
typedef enum __anonenum_usb_device_state_t_82 usb_device_state_t;
enum __anonenum_usb_device_trans_t_83 {
    USB_DEVICE_TRANS_POWER_INTERRUPT = 0,
    USB_DEVICE_TRANS_RESET = 1,
    USB_DEVICE_TRANS_BUS_INACTIVE = 2,
    USB_DEVICE_TRANS_BUS_ACTIVE = 3,
    USB_DEVICE_TRANS_HUB_CONFIGURED = 4,
    USB_DEVICE_TRANS_HUB_DECONFIGURED = 5,
    USB_DEVICE_TRANS_HUB_RESET = 6,
    USB_DEVICE_TRANS_ADDRESS_ASSIGNED = 7,
    USB_DEVICE_TRANS_DEV_CONFIGURED = 8,
    USB_DEVICE_TRANS_DEV_DECONFIGURED = 9
};
typedef enum __anonenum_usb_device_trans_t_83 usb_device_trans_t;
struct __anonstruct_usbctrl_device_descriptor_t_82 {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint16_t bcdUSB ;
   uint8_t bDeviceClass ;
   uint8_t bDeviceSubClass ;
   uint8_t bDeviceProtocol ;
   uint8_t bMaxPacketSize ;
   uint16_t idVendor ;
   uint16_t idProduct ;
   uint16_t bcdDevice ;
   uint8_t iManufacturer ;
   uint8_t iProduct ;
   uint8_t iSerialNumber ;
   uint8_t bNumConfigurations ;
} __attribute__((__packed__));
typedef struct __anonstruct_usbctrl_device_descriptor_t_82 usbctrl_device_descriptor_t;
struct __anonstruct_bmAttributes_84 {
   uint8_t reserved : 5 ;
   uint8_t remote_wakeup : 1 ;
   uint8_t self_powered : 1 ;
   uint8_t reserved7 : 1 ;
};
struct __anonstruct_usbctrl_configuration_descriptor_t_83 {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint16_t wTotalLength ;
   uint8_t bNumInterfaces ;
   uint8_t bConfigurationValue ;
   uint8_t iConfiguration ;
   struct __anonstruct_bmAttributes_84 bmAttributes ;
   uint8_t bMaxPower ;
} __attribute__((__packed__));
typedef struct __anonstruct_usbctrl_configuration_descriptor_t_83 usbctrl_configuration_descriptor_t;
struct __anonstruct_usbctrl_interface_descriptor_t_85 {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint8_t bInterfaceNumber ;
   uint8_t bAlternateSetting ;
   uint8_t bNumEndpoints ;
   uint8_t bInterfaceClass ;
   uint8_t bInterfaceSubClass ;
   uint8_t bInterfaceProtocol ;
   uint8_t iInterface ;
} __attribute__((__packed__));
typedef struct __anonstruct_usbctrl_interface_descriptor_t_85 usbctrl_interface_descriptor_t;
struct __anonstruct_usbctrl_endpoint_descriptor_t_86 {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint8_t bEndpointAddress ;
   uint8_t bmAttributes ;
   uint16_t wMaxPacketSize ;
   uint8_t bInterval ;
} __attribute__((__packed__));
typedef struct __anonstruct_usbctrl_endpoint_descriptor_t_86 usbctrl_endpoint_descriptor_t;
struct __anonstruct_usbctrl_string_descriptor_t_87 {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint16_t wString[32] ;
} __attribute__((__packed__));
typedef struct __anonstruct_usbctrl_string_descriptor_t_87 usbctrl_string_descriptor_t;
enum __anonenum_usbctrl_req_type_t_93 {
    USB_REQ_TYPE_STD = 0,
    USB_REQ_TYPE_CLASS = 1,
    USB_REQ_TYPE_VENDOR = 2,
    USB_REQ_TYPE_RESERVED = 3
};
typedef enum __anonenum_usbctrl_req_type_t_93 usbctrl_req_type_t;
enum __anonenum_usbctrl_req_dir_t_94 {
    USB_REQ_DIR_H2D = 0,
    USB_REQ_DIR_D2H = 1
};
typedef enum __anonenum_usbctrl_req_dir_t_94 usbctrl_req_dir_t;
enum __anonenum_usbctrl_req_recipient_t_95 {
    USB_REQ_RECIPIENT_DEVICE = 0,
    USB_REQ_RECIPIENT_INTERFACE = 1,
    USB_REQ_RECIPIENT_ENDPOINT = 2,
    USB_REQ_RECIPIENT_OTHER = 3
};
typedef enum __anonenum_usbctrl_req_recipient_t_95 usbctrl_req_recipient_t;
enum __anonenum_usbctrl_req_descriptor_type_t_96 {
    USB_REQ_DESCRIPTOR_DEVICE = 1,
    USB_REQ_DESCRIPTOR_CONFIGURATION = 2,
    USB_REQ_DESCRIPTOR_STRING = 3,
    USB_REQ_DESCRIPTOR_INTERFACE = 4,
    USB_REQ_DESCRIPTOR_ENDPOINT = 5,
    USB_REQ_DESCRIPTOR_DEVICE_QUALIFIER = 6,
    USB_REQ_DESCRIPTOR_OTHER_SPEED_CFG = 7,
    USB_REQ_DESCRIPTOR_INTERFACE_POWER = 8
};
typedef enum __anonenum_usbctrl_req_descriptor_type_t_96 usbctrl_req_descriptor_type_t;
struct usb_operation_code_transition {
   uint8_t request ;
   uint8_t target_state ;
};
typedef struct usb_operation_code_transition usb_request_code_transition_t;
struct __anonstruct_usb_automaton_84 {
   usb_device_state_t state ;
   usb_request_code_transition_t req_trans[10] ;
};
__inline static uint8_t min_u8(uint8_t x, uint8_t y)
{
  uint8_t __retres;
  if ((int)x < (int)y) {
    __retres = x;
    goto return_label;
  }
  else {
    __retres = y;
    goto return_label;
  }
  return_label: return __retres;
}

static uint32_t get_reg_value(uint32_t const volatile *reg, uint32_t mask,
                              uint8_t pos);

static int8_t set_reg_value(uint32_t volatile *reg, uint32_t value,
                            uint32_t mask, uint8_t pos);

static uint32_t read_reg_value(uint32_t volatile *reg);

static uint16_t read_reg16_value(uint16_t volatile *reg);

static void write_reg_value(uint32_t volatile *reg, uint32_t value);

static void write_reg16_value(uint16_t volatile *reg, uint16_t value);

static void set_reg_bits(uint32_t volatile *reg, uint32_t value);

static void clear_reg_bits(uint32_t volatile *reg, uint32_t value);

static uint32_t get_reg_value(uint32_t const volatile *reg, uint32_t mask,
                              uint8_t pos)
{
  uint32_t __retres;
  if (mask == (uint32_t)0x00) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((int)pos > 31) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (*reg & mask) >> (int)pos;
  return_label: return __retres;
}

__inline static uint16_t get_reg16_value(uint16_t volatile *reg,
                                         uint16_t mask, uint8_t pos)
{
  uint16_t __retres;
  if ((int)mask == 0x00) {
    __retres = (unsigned short)0;
    goto return_label;
  }
  else 
    if ((int)pos > 15) {
      __retres = (unsigned short)0;
      goto return_label;
    }
  __retres = (unsigned short)(((int)*reg & (int)mask) >> (int)pos);
  return_label: return __retres;
}

static int8_t set_reg_value(uint32_t volatile *reg, uint32_t value,
                            uint32_t mask, uint8_t pos)
{
  int8_t __retres;
  uint32_t tmp;
  if ((int)pos > 31) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if (mask == 0xFFFFFFFF) *reg = value;
  else {
    tmp = read_reg_value(reg);
    tmp &= ~ mask;
    tmp |= (value << (int)pos) & mask;
    write_reg_value(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

__inline static int8_t set_reg16_value(uint16_t volatile *reg,
                                       uint16_t value, uint16_t mask,
                                       uint8_t pos)
{
  int8_t __retres;
  uint16_t tmp;
  if ((int)pos > 15) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if ((int)mask == 0xFFFF) *reg = value;
  else {
    tmp = read_reg16_value(reg);
    tmp = (unsigned short)((int)tmp & (int)((unsigned short)(~ ((int)mask))));
    tmp = (unsigned short)((int)tmp | (int)((unsigned short)(((int)value << (int)pos) & (int)mask)));
    write_reg16_value(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

static uint32_t read_reg_value(uint32_t volatile *reg)
{
  uint32_t __retres;
  __retres = *reg;
  return __retres;
}

static uint16_t read_reg16_value(uint16_t volatile *reg)
{
  uint16_t __retres;
  __retres = *reg;
  return __retres;
}

static void write_reg_value(uint32_t volatile *reg, uint32_t value)
{
  *reg = value;
  return;
}

static void write_reg16_value(uint16_t volatile *reg, uint16_t value)
{
  *reg = value;
  return;
}

static void set_reg_bits(uint32_t volatile *reg, uint32_t value)
{
  *reg |= value;
  return;
}

__inline static void set_reg16_bits(uint16_t volatile *reg, uint16_t value)
{
  *reg = (unsigned short)((int)*reg | (int)value);
  return;
}

static void clear_reg_bits(uint32_t volatile *reg, uint32_t value)
{
  *reg &= ~ value;
  return;
}

e_syscall_ret sys_init_INIT_DEVACCESS(uint32_t inittype,
                                      device_t const *device, int *descriptor);

e_syscall_ret sys_cfg_CFG_DEV_MAP(uint32_t cfgtype, uint32_t devid);

mbed_error_t usb_backend_drv_configure(usb_backend_drv_mode_t mode,
                                       mbed_error_t (*ieph)(uint32_t dev_id,
                                                            uint32_t size,
                                                            uint8_t ep),
                                       mbed_error_t (*oeph)(uint32_t dev_id,
                                                            uint32_t size,
                                                            uint8_t ep));

mbed_error_t usb_backend_drv_declare(void);

mbed_error_t usb_backend_drv_activate_endpoint(uint8_t id,
                                               usb_backend_drv_ep_dir_t dir);

mbed_error_t usb_backend_drv_configure_endpoint(uint8_t ep,
                                                usb_backend_drv_ep_type_t type,
                                                usb_backend_drv_ep_dir_t dir,
                                                usb_backend_drv_epx_mpsize_t mpsize,
                                                usb_backend_drv_ep_toggle_t dtoggle,
                                                mbed_error_t (*handler)
                                                (uint32_t dev_id,
                                                 uint32_t size, uint8_t ep));

mbed_error_t usb_backend_drv_get_ep_state(uint8_t epnum,
                                          usb_backend_drv_ep_dir_t dir);

mbed_error_t usb_backend_drv_send_data(uint8_t *src, uint32_t size,
                                       uint8_t ep);

mbed_error_t usb_backend_drv_send_zlp(uint8_t ep);

void usb_backend_drv_set_address(uint16_t addr);

mbed_error_t usb_backend_drv_set_recv_fifo(uint8_t *dst, uint32_t size,
                                           uint8_t ep);

mbed_error_t usb_backend_drv_ack(uint8_t ep_id, usb_backend_drv_ep_dir_t dir);

mbed_error_t usb_backend_drv_nak(uint8_t ep_id, usb_backend_drv_ep_dir_t dir);

mbed_error_t usb_backend_drv_stall(uint8_t ep_id,
                                   usb_backend_drv_ep_dir_t dir);

mbed_error_t usb_backend_drv_endpoint_disable(uint8_t ep_id,
                                              usb_backend_drv_ep_dir_t dir);

mbed_error_t usb_backend_drv_endpoint_enable(uint8_t ep_id,
                                             usb_backend_drv_ep_dir_t dir);

uint32_t usb_backend_get_ep_mpsize(void);

usb_backend_drv_port_speed_t usb_backend_drv_get_speed(void);

mbed_error_t usbctrl_handle_earlysuspend(uint32_t dev_id);

mbed_error_t usbctrl_handle_reset(uint32_t dev_id);

mbed_error_t usbctrl_handle_usbsuspend(uint32_t dev_id);

mbed_error_t usbctrl_handle_inepevent(uint32_t dev_id, uint32_t size,
                                      uint8_t ep);

mbed_error_t usbctrl_handle_outepevent(uint32_t dev_id, uint32_t size,
                                       uint8_t ep);

mbed_error_t usbctrl_handle_wakeup(uint32_t dev_id);

mbed_error_t usbotghs_configure(usbotghs_dev_mode_t mode,
                                mbed_error_t (*ieph)(uint32_t dev_id,
                                                     uint32_t size,
                                                     uint8_t ep),
                                mbed_error_t (*oeph)(uint32_t dev_id,
                                                     uint32_t size,
                                                     uint8_t ep));

mbed_error_t usbotghs_send_data(uint8_t *src, uint32_t size, uint8_t ep_id);

mbed_error_t usbotghs_send_zlp(uint8_t ep_id);

mbed_error_t usbotghs_global_stall(void);

mbed_error_t usbotghs_global_stall_clear(void);

mbed_error_t usbotghs_endpoint_stall(uint8_t ep_id, usbotghs_ep_dir_t dir);

mbed_error_t usbotghs_endpoint_stall_clear(uint8_t ep, usbotghs_ep_dir_t dir);

mbed_error_t usbotghs_endpoint_set_nak(uint8_t ep_id, usbotghs_ep_dir_t dir);

mbed_error_t usbotghs_endpoint_clear_nak(uint8_t ep_id, usbotghs_ep_dir_t dir);

mbed_error_t usbotghs_configure_endpoint(uint8_t ep, usbotghs_ep_type_t type,
                                         usbotghs_ep_dir_t dir,
                                         usbotghs_epx_mpsize_t mpsize,
                                         usbotghs_ep_toggle_t dtoggle,
                                         mbed_error_t (*handler)(uint32_t dev_id,
                                                                 uint32_t size,
                                                                 uint8_t ep));

mbed_error_t usbotghs_deconfigure_endpoint(uint8_t ep);

mbed_error_t usbotghs_activate_endpoint(uint8_t ep_id, usbotghs_ep_dir_t dir);

mbed_error_t usbotghs_deactivate_endpoint(uint8_t ep, usbotghs_ep_dir_t dir);

mbed_error_t usbotghs_endpoint_disable(uint8_t ep_id, usbotghs_ep_dir_t dir);

mbed_error_t usbotghs_endpoint_enable(uint8_t ep_id, usbotghs_ep_dir_t dir);

void usbotghs_set_address(uint16_t addr);

usbotghs_ep_state_t usbotghs_get_ep_state(uint8_t epnum,
                                          usbotghs_ep_dir_t dir);

uint32_t usbotghs_get_ep_mpsize(void);

usbotghs_context_t *usbotghs_get_context(void);

mbed_error_t usbotghs_declare(void);

void usbctrl_configuration_set(void);

void usbctrl_reset_received(void);

mbed_error_t usbctrl_declare(uint32_t dev_id, uint32_t *ctxh);

mbed_error_t usbctrl_initialize(uint32_t ctxh);

mbed_error_t usbctrl_declare_interface(uint32_t ctxh,
                                       usbctrl_interface_t *iface);

mbed_error_t usbctrl_start_device(uint32_t ctxh);

mbed_error_t usbctrl_stop_device(uint32_t ctxh);

uint32_t strlen(char const *s);

void *memcpy(void *dest, void const *src, uint32_t n);

void *memset(void *s, int c, uint32_t n);

mbed_error_t usbctrl_get_context(uint32_t device_id, usbctrl_context_t **ctx);

bool usbctrl_is_endpoint_exists(usbctrl_context_t *ctx, uint8_t ep);

bool usbctrl_is_interface_exists(usbctrl_context_t *ctx, uint8_t iface);

usbctrl_interface_t *usbctrl_get_interface(usbctrl_context_t *ctx,
                                           uint8_t iface);

mbed_error_t usbctrl_get_handler(usbctrl_context_t *ctx, uint32_t *handler);

mbed_error_t usbctrl_handle_requests(usbctrl_setup_pkt_t *pkt,
                                     uint32_t dev_id);

usb_device_state_t usbctrl_get_state(usbctrl_context_t const *ctx);

mbed_error_t usbctrl_set_state(usbctrl_context_t volatile *ctx,
                               usb_device_state_t newstate);

uint8_t usbctrl_next_state(usb_device_state_t current_state,
                           usbctrl_request_code_t request);

bool usbctrl_is_valid_transition(usb_device_state_t current_state,
                                 usb_device_trans_t transition,
                                 usbctrl_context_t *ctx);

static uint8_t num_ctx = (unsigned char)0;
usbctrl_context_t ctx_list[2] =
  {{.dev_id = (unsigned int)0,
    .address = (unsigned short)0,
    .num_cfg = (unsigned char)0,
    .curr_cfg = (unsigned char)0,
    .cfg = {{.first_free_epid = (unsigned char)0,
             .interface_num = (unsigned char)0,
             .interfaces = {{.id = (unsigned char)0,
                             .usb_class = 0,
                             .usb_subclass = (unsigned char)0,
                             .usb_protocol = (unsigned char)0,
                             .dedicated = 0,
                             .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                                               usbctrl_setup_pkt_t *inpkt))0,
                             .class_desc_handler = (mbed_error_t (*)(
                                                                    uint8_t iface_id,
                                                                    uint8_t *buf,
                                                                    uint32_t *desc_size,
                                                                    uint32_t usbdci_handler))0,
                             .usb_ep_number = (unsigned char)0,
                             .eps = {{.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0}}},
                            {.id = (unsigned char)0,
                             .usb_class = 0,
                             .usb_subclass = (unsigned char)0,
                             .usb_protocol = (unsigned char)0,
                             .dedicated = 0,
                             .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                                               usbctrl_setup_pkt_t *inpkt))0,
                             .class_desc_handler = (mbed_error_t (*)(
                                                                    uint8_t iface_id,
                                                                    uint8_t *buf,
                                                                    uint32_t *desc_size,
                                                                    uint32_t usbdci_handler))0,
                             .usb_ep_number = (unsigned char)0,
                             .eps = {{.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0}}},
                            {.id = (unsigned char)0,
                             .usb_class = 0,
                             .usb_subclass = (unsigned char)0,
                             .usb_protocol = (unsigned char)0,
                             .dedicated = 0,
                             .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                                               usbctrl_setup_pkt_t *inpkt))0,
                             .class_desc_handler = (mbed_error_t (*)(
                                                                    uint8_t iface_id,
                                                                    uint8_t *buf,
                                                                    uint32_t *desc_size,
                                                                    uint32_t usbdci_handler))0,
                             .usb_ep_number = (unsigned char)0,
                             .eps = {{.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0}}},
                            {.id = (unsigned char)0,
                             .usb_class = 0,
                             .usb_subclass = (unsigned char)0,
                             .usb_protocol = (unsigned char)0,
                             .dedicated = 0,
                             .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                                               usbctrl_setup_pkt_t *inpkt))0,
                             .class_desc_handler = (mbed_error_t (*)(
                                                                    uint8_t iface_id,
                                                                    uint8_t *buf,
                                                                    uint32_t *desc_size,
                                                                    uint32_t usbdci_handler))0,
                             .usb_ep_number = (unsigned char)0,
                             .eps = {{.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0}}}}},
            {.first_free_epid = (unsigned char)0,
             .interface_num = (unsigned char)0,
             .interfaces = {{.id = (unsigned char)0,
                             .usb_class = 0,
                             .usb_subclass = (unsigned char)0,
                             .usb_protocol = (unsigned char)0,
                             .dedicated = 0,
                             .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                                               usbctrl_setup_pkt_t *inpkt))0,
                             .class_desc_handler = (mbed_error_t (*)(
                                                                    uint8_t iface_id,
                                                                    uint8_t *buf,
                                                                    uint32_t *desc_size,
                                                                    uint32_t usbdci_handler))0,
                             .usb_ep_number = (unsigned char)0,
                             .eps = {{.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0}}},
                            {.id = (unsigned char)0,
                             .usb_class = 0,
                             .usb_subclass = (unsigned char)0,
                             .usb_protocol = (unsigned char)0,
                             .dedicated = 0,
                             .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                                               usbctrl_setup_pkt_t *inpkt))0,
                             .class_desc_handler = (mbed_error_t (*)(
                                                                    uint8_t iface_id,
                                                                    uint8_t *buf,
                                                                    uint32_t *desc_size,
                                                                    uint32_t usbdci_handler))0,
                             .usb_ep_number = (unsigned char)0,
                             .eps = {{.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0}}},
                            {.id = (unsigned char)0,
                             .usb_class = 0,
                             .usb_subclass = (unsigned char)0,
                             .usb_protocol = (unsigned char)0,
                             .dedicated = 0,
                             .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                                               usbctrl_setup_pkt_t *inpkt))0,
                             .class_desc_handler = (mbed_error_t (*)(
                                                                    uint8_t iface_id,
                                                                    uint8_t *buf,
                                                                    uint32_t *desc_size,
                                                                    uint32_t usbdci_handler))0,
                             .usb_ep_number = (unsigned char)0,
                             .eps = {{.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0}}},
                            {.id = (unsigned char)0,
                             .usb_class = 0,
                             .usb_subclass = (unsigned char)0,
                             .usb_protocol = (unsigned char)0,
                             .dedicated = 0,
                             .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                                               usbctrl_setup_pkt_t *inpkt))0,
                             .class_desc_handler = (mbed_error_t (*)(
                                                                    uint8_t iface_id,
                                                                    uint8_t *buf,
                                                                    uint32_t *desc_size,
                                                                    uint32_t usbdci_handler))0,
                             .usb_ep_number = (unsigned char)0,
                             .eps = {{.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0},
                                     {.type = 0,
                                      .dir = 0,
                                      .attr = 0,
                                      .usage = 0,
                                      .pkt_maxsize = (unsigned short)0,
                                      .handler = (mbed_error_t (*)(uint32_t dev_id,
                                                                   uint32_t size,
                                                                   uint8_t ep_id))0,
                                      .ep_num = (unsigned char)0,
                                      .poll_interval = (unsigned char)0,
                                      .configured = 0}}}}}},
    .state = (unsigned char)0,
    .ctrl_fifo = {(unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0,
                  (unsigned char)0},
    .ctrl_fifo_state = 0,
    .ctrl_req_processing = 0}};
/*@ requires \valid(ctxh);
    
    behavior bad_ctxh:
      assumes ctxh  (uint32_t *)((void *)0);
      ensures \result  MBED_ERROR_INVPARAM;
    
    behavior bad_num_ctx:
      assumes num_ctx  2;
      ensures \result  MBED_ERROR_NOMEM;
      assigns \nothing;
    
    behavior bad_dev_id:
      assumes dev_id  7  dev_id  6;
      ensures \result  MBED_ERROR_NOBACKEND;
      assigns \nothing;
    
    behavior ok:
      assumes
        (dev_id  7  dev_id  6)  num_ctx < 2 
        ctxh  (uint32_t *)((void *)0);
      ensures \result  MBED_ERROR_NONE;
      ensures 0  *\old(ctxh) < 2;
      assigns *ctxh;
    
    complete behaviors ok, bad_dev_id, bad_num_ctx, bad_ctxh;
    disjoint behaviors ok, bad_dev_id, bad_num_ctx, bad_ctxh;
 */
mbed_error_t usbctrl_declare(uint32_t dev_id, uint32_t *ctxh)
{
  uint8_t i;
  mbed_error_t errcode = MBED_ERROR_NONE;
  if (ctxh == (uint32_t *)0) {
    errcode = MBED_ERROR_INVPARAM;
    goto err;
  }
  if ((int)num_ctx >= 2) {
    errcode = MBED_ERROR_NOMEM;
    goto err;
  }
  switch (dev_id) {
    case (uint32_t)7: errcode = usbotghs_declare();
    break;
    case (uint32_t)6: errcode = usb_backend_drv_declare();
    break;
    default: errcode = MBED_ERROR_NOBACKEND;
    goto err;
    break;
  }
  ctx_list[num_ctx].dev_id = dev_id;
  *ctxh = (unsigned int)num_ctx;
  usbctrl_context_t *ctx = & ctx_list[num_ctx];
  num_ctx = (uint8_t)((int)num_ctx + 1);
  ctx->num_cfg = (unsigned char)1;
  i = (unsigned char)0;
  /*@ loop unroll 2; */
  while ((int)i < 2) {
    ctx->cfg[i].interface_num = (unsigned char)0;
    ctx->cfg[i].first_free_epid = (unsigned char)1;
    i = (uint8_t)((int)i + 1);
  }
  ctx->address = (unsigned short)0;
  ctx->curr_cfg = (unsigned char)0;
  err: ;
  return errcode;
}

/*@ assigns \result;
    assigns \result \from (indirect: *(fmt + (0 ..))); */
int printf_va_1(char const *fmt);

mbed_error_t usbctrl_initialize(uint32_t ctxh)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  if (ctxh >= (uint32_t)num_ctx) {
    errcode = MBED_ERROR_INVPARAM;
    goto end;
  }
  usbctrl_context_t volatile *ctx =
    (usbctrl_context_t volatile *)(& ctx_list[ctxh]);
  printf_va_1("[USBCTRL] initializing automaton\n");
  memset((void *)(ctx->cfg[ctx->curr_cfg].interfaces),0x0,
         (unsigned int)4 * sizeof(usbctrl_interface_t));
  ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_NOSTORAGE;
  usbctrl_set_state(ctx,USB_DEVICE_STATE_POWERED);
  ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_FREE;
  ctx->ctrl_req_processing = false;
  ctx->cfg[0].first_free_epid = (unsigned char)1;
  end: ;
  return errcode;
}

mbed_error_t usbctrl_get_handler(usbctrl_context_t *ctx, uint32_t *handler)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  if (ctx == (usbctrl_context_t *)0) goto _LOR;
  else 
    if (handler == (uint32_t *)0) {
      _LOR: {
              errcode = MBED_ERROR_INVPARAM;
              goto end;
            }
    }
  {
    uint8_t i = (unsigned char)0;
    /*@ loop unroll num_ctx; */
    while ((int)i < (int)num_ctx) {
      if (& ctx_list[i] == ctx) {
        *handler = (unsigned int)i;
        goto end;
      }
      i = (uint8_t)((int)i + 1);
    }
  }
  errcode = MBED_ERROR_NOTFOUND;
  end: ;
  return errcode;
}

mbed_error_t usbctrl_get_context(uint32_t device_id, usbctrl_context_t **ctx)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  if (ctx == (usbctrl_context_t **)0) {
    errcode = MBED_ERROR_INVPARAM;
    goto end;
  }
  {
    uint8_t i = (unsigned char)0;
    /*@ loop unroll num_ctx; */
    while ((int)i < (int)num_ctx) {
      if (ctx_list[i].dev_id == device_id) {
        *ctx = & ctx_list[i];
        goto end;
      }
      i = (uint8_t)((int)i + 1);
    }
  }
  errcode = MBED_ERROR_NOTFOUND;
  end: ;
  return errcode;
}

bool usbctrl_is_endpoint_exists(usbctrl_context_t *ctx, uint8_t ep)
{
  bool __retres;
  uint8_t i;
  if ((int)ep == EP0) {
    __retres = true;
    goto return_label;
  }
  i = (unsigned char)0;
  /*@ loop unroll ctx->cfg[ctx->curr_cfg].interface_num; */
  while ((int)i < (int)ctx->cfg[ctx->curr_cfg].interface_num) {
    {
      uint8_t j = (unsigned char)0;
      /*@ loop unroll ctx->cfg[ctx->curr_cfg].interfaces[i].usb_ep_number; */
      while ((int)j < (int)ctx->cfg[ctx->curr_cfg].interfaces[i].usb_ep_number) {
        if ((int)ctx->cfg[ctx->curr_cfg].interfaces[i].eps[j].ep_num == (int)ep) {
          __retres = true;
          goto return_label;
        }
        j = (uint8_t)((int)j + 1);
      }
    }
    i = (uint8_t)((int)i + 1);
  }
  __retres = false;
  return_label: return __retres;
}

bool usbctrl_is_interface_exists(usbctrl_context_t *ctx, uint8_t iface)
{
  bool __retres;
  if (ctx == (usbctrl_context_t *)0) {
    __retres = false;
    goto return_label;
  }
  if ((int)iface < (int)ctx->cfg[ctx->curr_cfg].interface_num) {
    __retres = true;
    goto return_label;
  }
  __retres = false;
  return_label: return __retres;
}

usbctrl_interface_t *usbctrl_get_interface(usbctrl_context_t *ctx,
                                           uint8_t iface)
{
  usbctrl_interface_t *__retres;
  if (ctx == (usbctrl_context_t *)0) {
    __retres = (usbctrl_interface_t *)0;
    goto return_label;
  }
  if ((int)iface < (int)ctx->cfg[ctx->curr_cfg].interface_num) {
    __retres = & ctx->cfg[ctx->curr_cfg].interfaces[iface];
    goto return_label;
  }
  __retres = (usbctrl_interface_t *)0;
  return_label: return __retres;
}

/*@ assigns \result;
    assigns \result \from (indirect: *(fmt + (0 ..))); */
int printf_va_2(char const *fmt);

/*@ assigns \result;
    assigns \result \from (indirect: *(fmt + (0 ..))), (indirect: param0);
 */
int printf_va_3(char const *fmt, int param0);

mbed_error_t usbctrl_declare_interface(uint32_t ctxh,
                                       usbctrl_interface_t *iface)
{
  uint8_t iface_config = (unsigned char)0;
  uint8_t i = (unsigned char)0;
  mbed_error_t errcode = MBED_ERROR_NONE;
  if (ctxh >= (uint32_t)num_ctx) {
    errcode = MBED_ERROR_INVPARAM;
    goto err;
  }
  if (iface == (usbctrl_interface_t *)0) {
    errcode = MBED_ERROR_INVPARAM;
    goto err;
  }
  usbctrl_context_t *ctx = & ctx_list[ctxh];
  if ((int)ctx->cfg[ctx->curr_cfg].interface_num >= 4) {
    errcode = MBED_ERROR_NOMEM;
    goto err;
  }
  if (iface->dedicated == (unsigned int)true) {
    if ((int)ctx->cfg[ctx->curr_cfg].interface_num != 0) {
      ctx->num_cfg = (uint8_t)((int)ctx->num_cfg + 1);
      iface_config = ctx->num_cfg;
      ctx->cfg[iface_config].first_free_epid = (unsigned char)1;
    }
    else goto _LAND;
  }
  else _LAND: iface_config = ctx->curr_cfg;
  if ((int)iface_config >= 2) {
    errcode = MBED_ERROR_NOMEM;
    goto err;
  }
  uint8_t iface_num = ctx->cfg[iface_config].interface_num;
  memcpy((void *)(& ctx->cfg[iface_config].interfaces[iface_num]),
         (void const *)iface,sizeof(usbctrl_interface_t));
  ctx->cfg[iface_config].interfaces[iface_num].id = iface_num;
  iface->id = iface_num;
  /*@
  assert ctx->cfg[iface_config].interfaces[iface_num].usb_ep_number  8; */
  ;
  i = (unsigned char)0;
  /*@ loop unroll ctx->cfg[iface_config].interfaces[iface_num].usb_ep_number;
  */
  while ((int)i < (int)ctx->cfg[iface_config].interfaces[iface_num].usb_ep_number) {
    {
      usb_ep_infos_t *ep =
        & ctx->cfg[iface_config].interfaces[iface_num].eps[i];
      ep->configured = false;
      if (ep->type == (unsigned int)USB_EP_TYPE_CONTROL) {
        printf_va_2("declare EP (control) id 0\n");
        ep->ep_num = (unsigned char)0;
        iface->eps[i].ep_num = (unsigned char)0;
      }
      else {
        uint32_t drv_ep_mpsize;
        ep->ep_num = ctx->cfg[iface_config].first_free_epid;
        iface->eps[i].ep_num = ep->ep_num;
        printf_va_3("declare EP (not control) id %d\n",(int)ep->ep_num);
        ctx->cfg[iface_config].first_free_epid = (uint8_t)((int)ctx->cfg[iface_config].first_free_epid + 1);
        drv_ep_mpsize = usb_backend_get_ep_mpsize();
        if ((uint32_t)ep->pkt_maxsize > drv_ep_mpsize) ep->pkt_maxsize = (unsigned short)drv_ep_mpsize;
      }
    }
    i = (uint8_t)((int)i + 1);
  }
  ctx->cfg[iface_config].interface_num = (uint8_t)((int)ctx->cfg[iface_config].interface_num + 1);
  err: ;
  return errcode;
}

/*@ assigns \result;
    assigns \result \from (indirect: *(fmt + (0 ..))); */
int printf_va_4(char const *fmt);

mbed_error_t usbctrl_start_device(uint32_t ctxh)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  if (ctxh >= (uint32_t)num_ctx) {
    errcode = MBED_ERROR_INVPARAM;
    goto end;
  }
  usbctrl_context_t volatile *ctx =
    (usbctrl_context_t volatile *)(& ctx_list[ctxh]);
  errcode = usb_backend_drv_configure(USB_BACKEND_DRV_MODE_DEVICE,
                                      & usbctrl_handle_inepevent,
                                      & usbctrl_handle_outepevent);
  if (errcode != (unsigned int)MBED_ERROR_NONE) {
    usbctrl_set_state(ctx,USB_DEVICE_STATE_INVALID);
    goto end;
  }
  errcode = usb_backend_drv_set_recv_fifo((uint8_t *)(& ctx->ctrl_fifo[0]),
                                          (unsigned int)128,(unsigned char)0);
  if (errcode != (unsigned int)MBED_ERROR_NONE) {
    printf_va_4("[USBCTRL] failed to initialize EP0 FIFO!\n");
    goto end;
  }
  end: ;
  return errcode;
}

mbed_error_t usbctrl_stop_device(uint32_t ctxh)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  if (ctxh >= (uint32_t)num_ctx) {
    errcode = MBED_ERROR_INVPARAM;
    goto err;
  }
  usbctrl_context_t volatile *ctx =
    (usbctrl_context_t volatile *)(& ctx_list[ctxh]);
  ctx = ctx;
  err: ;
  return errcode;
}

int main(void)
{
  int __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  tmp = Frama_C_interval(0,(2 ^ 32) - 1);
  uint32_t dev_id = (unsigned int)tmp;
  tmp_0 = Frama_C_interval(0,2 - 1);
  uint32_t ctxh = (unsigned int)tmp_0;
  tmp_1 = Frama_C_interval(0,(2 ^ 32) - 1);
  uint32_t handler = (unsigned int)tmp_1;
  tmp_2 = Frama_C_interval(0,255);
  uint8_t ep = (unsigned char)tmp_2;
  tmp_3 = Frama_C_interval(0,4 - 1);
  uint8_t iface = (unsigned char)tmp_3;
  tmp_4 = Frama_C_interval(0,8);
  uint8_t ep_number = (unsigned char)tmp_4;
  tmp_5 = Frama_C_interval(0,3);
  uint8_t EP_type = (unsigned char)tmp_5;
  tmp_6 = Frama_C_interval(0,17);
  uint8_t USB_class = (unsigned char)tmp_6;
  usbctrl_interface_t iface_1 =
    {.id = (unsigned char)0,
     .usb_class = (enum __anonenum_usb_class_t_69)USB_class,
     .usb_subclass = (unsigned char)0,
     .usb_protocol = (unsigned char)0,
     .dedicated = false,
     .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                       usbctrl_setup_pkt_t *inpkt))0,
     .class_desc_handler = (mbed_error_t (*)(uint8_t iface_id, uint8_t *buf,
                                             uint32_t *desc_size,
                                             uint32_t usbdci_handler))0,
     .usb_ep_number = ep_number,
     .eps = {{.type = (enum __anonenum_usb_ep_type_t_70)EP_type,
              .dir = 0,
              .attr = 0,
              .usage = 0,
              .pkt_maxsize = (unsigned short)0,
              .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                           uint8_t ep_id))0,
              .ep_num = (unsigned char)0,
              .poll_interval = (unsigned char)0,
              .configured = 0}}};
  usbctrl_interface_t iface_2 =
    {.id = (unsigned char)0,
     .usb_class = (enum __anonenum_usb_class_t_69)USB_class,
     .usb_subclass = (unsigned char)0,
     .usb_protocol = (unsigned char)0,
     .dedicated = true,
     .rqst_handler = (mbed_error_t (*)(uint32_t usbdci_handler,
                                       usbctrl_setup_pkt_t *inpkt))0,
     .class_desc_handler = (mbed_error_t (*)(uint8_t iface_id, uint8_t *buf,
                                             uint32_t *desc_size,
                                             uint32_t usbdci_handler))0,
     .usb_ep_number = ep_number,
     .eps = {{.type = (enum __anonenum_usb_ep_type_t_70)EP_type,
              .dir = 0,
              .attr = 0,
              .usage = 0,
              .pkt_maxsize = (unsigned short)0,
              .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                           uint8_t ep_id))0,
              .ep_num = (unsigned char)0,
              .poll_interval = (unsigned char)0,
              .configured = 0}}};
  usbctrl_declare(dev_id,& ctxh);
  usbctrl_initialize(ctxh);
  usbctrl_get_handler(& ctx_list[ctxh],& handler);
  usbctrl_get_context(dev_id,(usbctrl_context_t **)(& ctx_list[ctxh]));
  usbctrl_declare_interface(ctxh,& iface_1);
  usbctrl_get_interface(& ctx_list[ctxh],iface);
  usbctrl_declare_interface(ctxh,& iface_2);
  usbctrl_get_interface(& ctx_list[ctxh],iface);
  usbctrl_is_endpoint_exists(& ctx_list[ctxh],ep);
  usbctrl_is_interface_exists(& ctx_list[ctxh],iface);
  usbctrl_start_device(ctxh);
  usbctrl_handle_earlysuspend(dev_id);
  usbctrl_handle_reset(dev_id);
  __retres = 0;
  return __retres;
}

__inline static uint8_t min_u8_0(uint8_t x, uint8_t y)
{
  uint8_t __retres;
  if ((int)x < (int)y) {
    __retres = x;
    goto return_label;
  }
  else {
    __retres = y;
    goto return_label;
  }
  return_label: return __retres;
}

static uint32_t get_reg_value_0(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos);

static int8_t set_reg_value_0(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos);

static uint32_t read_reg_value_0(uint32_t volatile *reg);

static uint16_t read_reg16_value_0(uint16_t volatile *reg);

static void write_reg_value_0(uint32_t volatile *reg, uint32_t value);

static void write_reg16_value_0(uint16_t volatile *reg, uint16_t value);

static void set_reg_bits_0(uint32_t volatile *reg, uint32_t value);

static void clear_reg_bits_0(uint32_t volatile *reg, uint32_t value);

static uint32_t get_reg_value_0(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos)
{
  uint32_t __retres;
  if (mask == (uint32_t)0x00) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((int)pos > 31) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (*reg & mask) >> (int)pos;
  return_label: return __retres;
}

__inline static uint16_t get_reg16_value_0(uint16_t volatile *reg,
                                           uint16_t mask, uint8_t pos)
{
  uint16_t __retres;
  if ((int)mask == 0x00) {
    __retres = (unsigned short)0;
    goto return_label;
  }
  else 
    if ((int)pos > 15) {
      __retres = (unsigned short)0;
      goto return_label;
    }
  __retres = (unsigned short)(((int)*reg & (int)mask) >> (int)pos);
  return_label: return __retres;
}

static int8_t set_reg_value_0(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos)
{
  int8_t __retres;
  uint32_t tmp;
  if ((int)pos > 31) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if (mask == 0xFFFFFFFF) *reg = value;
  else {
    tmp = read_reg_value_0(reg);
    tmp &= ~ mask;
    tmp |= (value << (int)pos) & mask;
    write_reg_value_0(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

__inline static int8_t set_reg16_value_0(uint16_t volatile *reg,
                                         uint16_t value, uint16_t mask,
                                         uint8_t pos)
{
  int8_t __retres;
  uint16_t tmp;
  if ((int)pos > 15) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if ((int)mask == 0xFFFF) *reg = value;
  else {
    tmp = read_reg16_value_0(reg);
    tmp = (unsigned short)((int)tmp & (int)((unsigned short)(~ ((int)mask))));
    tmp = (unsigned short)((int)tmp | (int)((unsigned short)(((int)value << (int)pos) & (int)mask)));
    write_reg16_value_0(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

static uint32_t read_reg_value_0(uint32_t volatile *reg)
{
  uint32_t __retres;
  __retres = *reg;
  return __retres;
}

static uint16_t read_reg16_value_0(uint16_t volatile *reg)
{
  uint16_t __retres;
  __retres = *reg;
  return __retres;
}

static void write_reg_value_0(uint32_t volatile *reg, uint32_t value)
{
  *reg = value;
  return;
}

static void write_reg16_value_0(uint16_t volatile *reg, uint16_t value)
{
  *reg = value;
  return;
}

static void set_reg_bits_0(uint32_t volatile *reg, uint32_t value)
{
  *reg |= value;
  return;
}

__inline static void set_reg16_bits_0(uint16_t volatile *reg, uint16_t value)
{
  *reg = (unsigned short)((int)*reg | (int)value);
  return;
}

static void clear_reg_bits_0(uint32_t volatile *reg, uint32_t value)
{
  *reg &= ~ value;
  return;
}

mbed_error_t usbctrl_get_descriptor(usbctrl_descriptor_type_t type,
                                    uint8_t *buf, uint32_t *desc_size,
                                    usbctrl_context_t *ctx,
                                    usbctrl_setup_pkt_t *pkt);

mbed_error_t usbctrl_get_descriptor(usbctrl_descriptor_type_t type,
                                    uint8_t *buf, uint32_t *desc_size,
                                    usbctrl_context_t *ctx,
                                    usbctrl_setup_pkt_t *pkt)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  if (buf == (uint8_t *)0) goto _LOR;
  else 
    if (ctx == (usbctrl_context_t *)0) goto _LOR;
    else 
      if (desc_size == (uint32_t *)0) goto _LOR;
      else 
        if (pkt == (usbctrl_setup_pkt_t *)0) {
          _LOR: {
                  errcode = MBED_ERROR_INVPARAM;
                  goto err;
                }
        }
  switch (type) {
    case (usbctrl_descriptor_type_t)USB_DESC_DEVICE:
    {
      usbctrl_device_descriptor_t *desc = (usbctrl_device_descriptor_t *)buf;
      desc->bLength = (unsigned char)sizeof(usbctrl_device_descriptor_t);
      desc->bDescriptorType = (unsigned char)0x1;
      desc->bcdUSB = (unsigned short)0x0200;
      desc->bDeviceClass = (unsigned char)0;
      desc->bDeviceSubClass = (unsigned char)0;
      desc->bDeviceProtocol = (unsigned char)0;
      desc->bMaxPacketSize = (unsigned char)64;
      desc->idVendor = (unsigned short)0xDEAD;
      desc->idProduct = (unsigned short)0xCAFE;
      desc->bcdDevice = (unsigned short)0x000;
      desc->iManufacturer = (unsigned char)2;
      desc->iProduct = (unsigned char)1;
      desc->iSerialNumber = (unsigned char)3;
      desc->bNumConfigurations = ctx->num_cfg;
      *desc_size = sizeof(usbctrl_device_descriptor_t);
      break;
    }
    case (usbctrl_descriptor_type_t)USB_DESC_INTERFACE: ;
    *desc_size = (unsigned int)0;
    break;
    case (usbctrl_descriptor_type_t)USB_DESC_ENDPOINT: ;
    *desc_size = (unsigned int)0;
    break;
    case (usbctrl_descriptor_type_t)USB_DESC_STRING:
    {
      *desc_size = (unsigned int)0;
      uint32_t descriptor_size = sizeof(usbctrl_string_descriptor_t);
      if (descriptor_size > (uint32_t)256) {
        errcode = MBED_ERROR_UNSUPORTED_CMD;
        *desc_size = (unsigned int)0;
        goto err;
      }
      {
        uint8_t *string_desc = buf;
        usbctrl_string_descriptor_t *cfg =
          (usbctrl_string_descriptor_t *)(string_desc + 0);
        uint8_t string_type = (unsigned char)((int)pkt->wValue & 0xff);
        cfg->bDescriptorType = (unsigned char)USB_DESC_STRING;
        switch ((int)string_type) {
          case 0: cfg->bLength = (unsigned char)4;
          cfg->wString[0] = (unsigned short)0x0409;
          *desc_size = (unsigned int)4;
          break;
          case 2:
          cfg->bLength = (unsigned char)((unsigned int)2 + (unsigned int)2 * sizeof("ANSSI"));
          {
            uint32_t i = (unsigned int)0;
            while (i < sizeof("ANSSI")) {
              cfg->wString[i] = (unsigned short)*("ANSSI" + i);
              i ++;
            }
          }
          *desc_size = (unsigned int)2 + (unsigned int)2 * sizeof("ANSSI");
          break;
          case 1:
          cfg->bLength = (unsigned char)((unsigned int)2 + (unsigned int)2 * sizeof("wookey"));
          {
            uint32_t i_0 = (unsigned int)0;
            while (i_0 < sizeof("wookey")) {
              cfg->wString[i_0] = (unsigned short)*("wookey" + i_0);
              i_0 ++;
            }
          }
          *desc_size = (unsigned int)2 + (unsigned int)2 * sizeof("wookey");
          break;
          case 3:
          cfg->bLength = (unsigned char)((unsigned int)2 + (unsigned int)2 * sizeof("123456789012345678901234"));
          {
            uint32_t i_1 = (unsigned int)0;
            while (i_1 < sizeof("123456789012345678901234")) {
              cfg->wString[i_1] = (unsigned short)*("123456789012345678901234" + i_1);
              i_1 ++;
            }
          }
          *desc_size = (unsigned int)2 + (unsigned int)2 * sizeof("123456789012345678901234");
          break;
          default: ;
          errcode = MBED_ERROR_UNSUPORTED_CMD;
          goto err;
          break;
        }
      }
      break;
    }
    case (usbctrl_descriptor_type_t)USB_DESC_CONFIGURATION:
    {
      uint32_t handler;
      mbed_error_t tmp;
      uint8_t curr_cfg = ctx->curr_cfg;
      uint8_t iface_num = ctx->cfg[curr_cfg].interface_num;
      uint32_t class_desc_size = (unsigned int)0;
      tmp = usbctrl_get_handler(ctx,& handler);
      if (tmp != (unsigned int)MBED_ERROR_NONE) goto err;
      {
        uint8_t i_2 = (unsigned char)0;
        while ((int)i_2 < (int)iface_num) {
          if (ctx->cfg[curr_cfg].interfaces[i_2].class_desc_handler != (mbed_error_t (*)
              (uint8_t iface_id, uint8_t *buf, uint32_t *desc_size,
               uint32_t usbdci_handler))0) {
            uint32_t max_buf_size = (unsigned int)256;
            errcode = (*(ctx->cfg[curr_cfg].interfaces[i_2].class_desc_handler))
            (i_2,buf,& max_buf_size,handler);
            if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
            class_desc_size += max_buf_size;
          }
          i_2 = (uint8_t)((int)i_2 + 1);
        }
      }
      uint32_t descriptor_size_0 =
        sizeof(usbctrl_configuration_descriptor_t);
      {
        uint8_t i_3 = (unsigned char)0;
        while ((int)i_3 < (int)iface_num) {
          {
            uint8_t num_ep = (unsigned char)0;
            {
              uint8_t ep = (unsigned char)0;
              while ((int)ep < (int)ctx->cfg[curr_cfg].interfaces[i_3].usb_ep_number) {
                if (ctx->cfg[curr_cfg].interfaces[i_3].eps[ep].type != (unsigned int)USB_EP_TYPE_CONTROL) 
                  num_ep = (uint8_t)((int)num_ep + 1);
                ep = (uint8_t)((int)ep + 1);
              }
            }
            descriptor_size_0 += sizeof(usbctrl_interface_descriptor_t) + 
                                 (unsigned int)num_ep * sizeof(usbctrl_endpoint_descriptor_t);
          }
          i_3 = (uint8_t)((int)i_3 + 1);
        }
      }
      descriptor_size_0 += class_desc_size;
      if (descriptor_size_0 > (uint32_t)256) {
        errcode = MBED_ERROR_UNSUPORTED_CMD;
        *desc_size = (unsigned int)0;
        goto err;
      }
      uint32_t curr_offset = (unsigned int)0;
      uint8_t *config_desc = buf + curr_offset;
      {
        usbctrl_configuration_descriptor_t *cfg_0 =
          (usbctrl_configuration_descriptor_t *)(config_desc + 0);
        cfg_0->bLength = (unsigned char)sizeof(usbctrl_configuration_descriptor_t);
        cfg_0->wTotalLength = (unsigned short)descriptor_size_0;
        cfg_0->bDescriptorType = (unsigned char)USB_DESC_CONFIGURATION;
        cfg_0->bNumInterfaces = iface_num;
        cfg_0->bConfigurationValue = (unsigned char)1;
        cfg_0->iConfiguration = (unsigned char)0;
        cfg_0->bmAttributes.reserved7 = (unsigned char)1;
        cfg_0->bmAttributes.self_powered = (unsigned char)1;
        cfg_0->bmAttributes.remote_wakeup = (unsigned char)0;
        cfg_0->bmAttributes.reserved = (unsigned char)0;
        cfg_0->bMaxPower = (unsigned char)0;
        curr_offset += sizeof(usbctrl_configuration_descriptor_t);
      }
      {
        uint8_t iface_id = (unsigned char)0;
        while ((int)iface_id < (int)iface_num) {
          {
            usbctrl_interface_descriptor_t *cfg_1 =
              (usbctrl_interface_descriptor_t *)(buf + curr_offset);
            cfg_1->bLength = (unsigned char)sizeof(usbctrl_interface_descriptor_t);
            cfg_1->bDescriptorType = (unsigned char)USB_DESC_INTERFACE;
            cfg_1->bInterfaceNumber = iface_id;
            cfg_1->bAlternateSetting = (unsigned char)0;
            uint8_t num_ep_0 = (unsigned char)0;
            {
              uint8_t ep_0 = (unsigned char)0;
              while ((int)ep_0 < (int)ctx->cfg[curr_cfg].interfaces[iface_id].usb_ep_number) {
                if (ctx->cfg[curr_cfg].interfaces[iface_id].eps[ep_0].type != (unsigned int)USB_EP_TYPE_CONTROL) 
                  num_ep_0 = (uint8_t)((int)num_ep_0 + 1);
                ep_0 = (uint8_t)((int)ep_0 + 1);
              }
            }
            cfg_1->bNumEndpoints = num_ep_0;
            cfg_1->bInterfaceClass = (unsigned char)ctx->cfg[curr_cfg].interfaces[iface_id].usb_class;
            cfg_1->bInterfaceSubClass = ctx->cfg[curr_cfg].interfaces[iface_id].usb_subclass;
            cfg_1->bInterfaceProtocol = ctx->cfg[curr_cfg].interfaces[iface_id].usb_protocol;
            cfg_1->iInterface = (unsigned char)1;
            curr_offset += sizeof(usbctrl_interface_descriptor_t);
          }
          if (ctx->cfg[curr_cfg].interfaces[iface_id].class_desc_handler != (mbed_error_t (*)
              (uint8_t iface_id, uint8_t *buf, uint32_t *desc_size,
               uint32_t usbdci_handler))0) {
            uint32_t handler_0;
            mbed_error_t tmp_0;
            uint8_t *cfg_2 = buf + curr_offset;
            tmp_0 = usbctrl_get_handler(ctx,& handler_0);
            if (tmp_0 != (unsigned int)MBED_ERROR_NONE) ;
            uint32_t max_buf_size_0 = *desc_size - curr_offset;
            errcode = (*(ctx->cfg[curr_cfg].interfaces[iface_id].class_desc_handler))
            (iface_id,cfg_2,& max_buf_size_0,handler_0);
            if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
            curr_offset += max_buf_size_0;
          }
          {
            uint8_t i_4 = (unsigned char)0;
            while ((int)i_4 < (int)ctx->cfg[curr_cfg].interfaces[iface_id].usb_ep_number) {
              {
                if (ctx->cfg[curr_cfg].interfaces[iface_id].eps[i_4].type == (unsigned int)USB_EP_TYPE_CONTROL) 
                  goto __Cont;
                usbctrl_endpoint_descriptor_t *cfg_3 =
                  (usbctrl_endpoint_descriptor_t *)(buf + curr_offset);
                cfg_3->bLength = (unsigned char)sizeof(usbctrl_endpoint_descriptor_t);
                cfg_3->bDescriptorType = (unsigned char)USB_DESC_ENDPOINT;
                cfg_3->bEndpointAddress = ctx->cfg[curr_cfg].interfaces[iface_id].eps[i_4].ep_num;
                if (ctx->cfg[curr_cfg].interfaces[iface_id].eps[i_4].dir == (unsigned int)USB_EP_DIR_IN) 
                  cfg_3->bEndpointAddress = (unsigned char)((int)cfg_3->bEndpointAddress | 0x80);
                cfg_3->bmAttributes = (unsigned char)((ctx->cfg[curr_cfg].interfaces[iface_id].eps[i_4].type | (
                                                       ctx->cfg[curr_cfg].interfaces[iface_id].eps[i_4].attr << 2)) | (
                                                      ctx->cfg[curr_cfg].interfaces[iface_id].eps[i_4].usage << 4));
                cfg_3->wMaxPacketSize = ctx->cfg[curr_cfg].interfaces[iface_id].eps[i_4].pkt_maxsize;
                if (ctx->cfg[curr_cfg].interfaces[iface_id].eps[i_4].type == (unsigned int)USB_EP_TYPE_INTERRUPT) {
                  usb_backend_drv_port_speed_t tmp_1;
                  uint8_t poll =
                    ctx->cfg[curr_cfg].interfaces[iface_id].eps[i_4].poll_interval;
                  if ((int)poll == 0) poll = (unsigned char)1;
                  tmp_1 = usb_backend_drv_get_speed();
                  if (tmp_1 == (unsigned int)USB_BACKEND_DRV_PORT_HIGHSPEED) {
                    uint8_t i_5 = (unsigned char)0;
                    while (! ((int)poll & 0x1)) {
                      poll = (unsigned char)((int)poll >> 1);
                      i_5 = (uint8_t)((int)i_5 + 1);
                    }
                    i_5 = (unsigned char)((int)i_5 + 2);
                    cfg_3->bInterval = i_5;
                  }
                  else cfg_3->bInterval = poll;
                }
                else cfg_3->bInterval = (unsigned char)0;
                curr_offset += sizeof(usbctrl_endpoint_descriptor_t);
              }
              __Cont: i_4 = (uint8_t)((int)i_4 + 1);
            }
          }
          iface_id = (uint8_t)((int)iface_id + 1);
        }
      }
      *desc_size = descriptor_size_0;
      break;
    }
    case (usbctrl_descriptor_type_t)USB_DESC_DEV_QUALIFIER: ;
    *desc_size = (unsigned int)0;
    break;
    case (usbctrl_descriptor_type_t)USB_DESC_OTHER_SPEED_CFG: ;
    *desc_size = (unsigned int)0;
    break;
    case (usbctrl_descriptor_type_t)USB_DESC_IFACE_POWER: ;
    *desc_size = (unsigned int)0;
    break;
    default: ;
    errcode = MBED_ERROR_INVPARAM;
    goto err;
  }
  err: ;
  return errcode;
}

__inline static uint8_t min_u8_1(uint8_t x, uint8_t y)
{
  uint8_t __retres;
  if ((int)x < (int)y) {
    __retres = x;
    goto return_label;
  }
  else {
    __retres = y;
    goto return_label;
  }
  return_label: return __retres;
}

static uint32_t get_reg_value_1(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos);

static int8_t set_reg_value_1(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos);

static uint32_t read_reg_value_1(uint32_t volatile *reg);

static uint16_t read_reg16_value_1(uint16_t volatile *reg);

static void write_reg_value_1(uint32_t volatile *reg, uint32_t value);

static void write_reg16_value_1(uint16_t volatile *reg, uint16_t value);

static void set_reg_bits_1(uint32_t volatile *reg, uint32_t value);

static void clear_reg_bits_1(uint32_t volatile *reg, uint32_t value);

static uint32_t get_reg_value_1(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos)
{
  uint32_t __retres;
  if (mask == (uint32_t)0x00) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((int)pos > 31) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (*reg & mask) >> (int)pos;
  return_label: return __retres;
}

__inline static uint16_t get_reg16_value_1(uint16_t volatile *reg,
                                           uint16_t mask, uint8_t pos)
{
  uint16_t __retres;
  if ((int)mask == 0x00) {
    __retres = (unsigned short)0;
    goto return_label;
  }
  else 
    if ((int)pos > 15) {
      __retres = (unsigned short)0;
      goto return_label;
    }
  __retres = (unsigned short)(((int)*reg & (int)mask) >> (int)pos);
  return_label: return __retres;
}

static int8_t set_reg_value_1(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos)
{
  int8_t __retres;
  uint32_t tmp;
  if ((int)pos > 31) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if (mask == 0xFFFFFFFF) *reg = value;
  else {
    tmp = read_reg_value_1(reg);
    tmp &= ~ mask;
    tmp |= (value << (int)pos) & mask;
    write_reg_value_1(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

__inline static int8_t set_reg16_value_1(uint16_t volatile *reg,
                                         uint16_t value, uint16_t mask,
                                         uint8_t pos)
{
  int8_t __retres;
  uint16_t tmp;
  if ((int)pos > 15) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if ((int)mask == 0xFFFF) *reg = value;
  else {
    tmp = read_reg16_value_1(reg);
    tmp = (unsigned short)((int)tmp & (int)((unsigned short)(~ ((int)mask))));
    tmp = (unsigned short)((int)tmp | (int)((unsigned short)(((int)value << (int)pos) & (int)mask)));
    write_reg16_value_1(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

static uint32_t read_reg_value_1(uint32_t volatile *reg)
{
  uint32_t __retres;
  __retres = *reg;
  return __retres;
}

static uint16_t read_reg16_value_1(uint16_t volatile *reg)
{
  uint16_t __retres;
  __retres = *reg;
  return __retres;
}

static void write_reg_value_1(uint32_t volatile *reg, uint32_t value)
{
  *reg = value;
  return;
}

static void write_reg16_value_1(uint16_t volatile *reg, uint16_t value)
{
  *reg = value;
  return;
}

static void set_reg_bits_1(uint32_t volatile *reg, uint32_t value)
{
  *reg |= value;
  return;
}

__inline static void set_reg16_bits_1(uint16_t volatile *reg, uint16_t value)
{
  *reg = (unsigned short)((int)*reg | (int)value);
  return;
}

static void clear_reg_bits_1(uint32_t volatile *reg, uint32_t value)
{
  *reg &= ~ value;
  return;
}

mbed_error_t usbctrl_handle_earlysuspend(uint32_t dev_id)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  dev_id = dev_id;
  return errcode;
}

mbed_error_t usbctrl_handle_reset(uint32_t dev_id)
{
  mbed_error_t tmp;
  bool tmp_1;
  uint8_t tmp_2;
  mbed_error_t errcode = MBED_ERROR_NONE;
  dev_id = dev_id;
  usbctrl_context_t *ctx = (usbctrl_context_t *)0;
  dev_id = dev_id;
  tmp = usbctrl_get_context(dev_id,& ctx);
  if (tmp != (unsigned int)MBED_ERROR_NONE) {
    errcode = MBED_ERROR_INVPARAM;
    goto err;
  }
  usb_device_state_t state =
    usbctrl_get_state((usbctrl_context_t const *)ctx);
  tmp_1 = usbctrl_is_valid_transition(state,USB_DEVICE_TRANS_RESET,ctx);
  if (! tmp_1) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  switch (state) {
    case (usb_device_state_t)USB_DEVICE_STATE_POWERED: ;
    errcode = usb_backend_drv_set_recv_fifo(& ctx->ctrl_fifo[0],
                                            (unsigned int)128,
                                            (unsigned char)0);
    if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
    ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_FREE;
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_SUSPENDED_DEFAULT:
    errcode = usb_backend_drv_set_recv_fifo(& ctx->ctrl_fifo[0],
                                            (unsigned int)128,
                                            (unsigned char)0);
    if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
    ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_FREE;
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_SUSPENDED_ADDRESS:
    errcode = usb_backend_drv_set_recv_fifo(& ctx->ctrl_fifo[0],
                                            (unsigned int)128,
                                            (unsigned char)0);
    if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
    ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_FREE;
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_SUSPENDED_CONFIGURED:
    errcode = usb_backend_drv_set_recv_fifo(& ctx->ctrl_fifo[0],
                                            (unsigned int)128,
                                            (unsigned char)0);
    if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
    ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_FREE;
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_DEFAULT:
    errcode = usb_backend_drv_set_recv_fifo(& ctx->ctrl_fifo[0],
                                            (unsigned int)128,
                                            (unsigned char)0);
    if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
    ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_FREE;
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_ADDRESS:
    errcode = usb_backend_drv_set_recv_fifo(& ctx->ctrl_fifo[0],
                                            (unsigned int)128,
                                            (unsigned char)0);
    if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
    ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_FREE;
    ctx->address = (unsigned short)0;
    usb_backend_drv_set_address((unsigned short)0);
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_CONFIGURED:
    errcode = usb_backend_drv_set_recv_fifo(& ctx->ctrl_fifo[0],
                                            (unsigned int)128,
                                            (unsigned char)0);
    if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
    ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_FREE;
    ctx->address = (unsigned short)0;
    usb_backend_drv_set_address((unsigned short)0);
    usbctrl_reset_received();
    break;
    default:
    usbctrl_set_state((usbctrl_context_t volatile *)ctx,
                      USB_DEVICE_STATE_INVALID);
    errcode = MBED_ERROR_INVSTATE;
    goto err;
    break;
  }
  tmp_2 = usbctrl_next_state(state,
                             (enum __anonenum_usbctrl_request_code_t_79)USB_DEVICE_TRANS_RESET);
  ;
  usbctrl_set_state((usbctrl_context_t volatile *)ctx,
                    (enum __anonenum_usb_device_state_t_82)tmp_2);
  err: ;
  return errcode;
}

mbed_error_t usbctrl_handle_usbsuspend(uint32_t dev_id)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  dev_id = dev_id;
  return errcode;
}

mbed_error_t usbctrl_handle_inepevent(uint32_t dev_id, uint32_t size,
                                      uint8_t ep)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbctrl_context_t *ctx = (usbctrl_context_t *)0;
  errcode = usbctrl_get_context(dev_id,& ctx);
  if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
  uint8_t curr_cfg = ctx->curr_cfg;
  if (ctx->ctrl_req_processing == (unsigned int)true) ctx->ctrl_req_processing = false;
  else {
    {
      uint8_t iface = (unsigned char)0;
      while ((int)iface < (int)ctx->cfg[curr_cfg].interface_num) {
        {
          uint8_t i = (unsigned char)0;
          while ((int)i < (int)ctx->cfg[curr_cfg].interfaces[iface].usb_ep_number) {
            if ((int)ctx->cfg[curr_cfg].interfaces[iface].eps[i].ep_num == (int)ep) 
              if (ctx->cfg[curr_cfg].interfaces[iface].eps[i].dir == (unsigned int)USB_EP_DIR_IN) {
                if (ctx->cfg[curr_cfg].interfaces[iface].eps[i].handler) 
                  (*(ctx->cfg[curr_cfg].interfaces[iface].eps[i].handler))
                  (dev_id,size,ep);
                break;
              }
            i = (uint8_t)((int)i + 1);
          }
        }
        iface = (uint8_t)((int)iface + 1);
      }
    }
  }
  dev_id = dev_id;
  err: ;
  return errcode;
}

mbed_error_t usbctrl_handle_outepevent(uint32_t dev_id, uint32_t size,
                                       uint8_t ep)
{
  mbed_error_t __retres;
  mbed_error_t tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbctrl_context_t *ctx = (usbctrl_context_t *)0;
  errcode = usbctrl_get_context(dev_id,& ctx);
  if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
  tmp = usb_backend_drv_get_ep_state(ep,USB_BACKEND_DRV_EP_DIR_OUT);
  switch (tmp) {
    case (mbed_error_t)USB_BACKEND_DRV_EP_STATE_SETUP: ;
    if (size == (uint32_t)8) {
      uint8_t *setup_packet = ctx->ctrl_fifo;
      usbctrl_setup_pkt_t formated_pkt =
        {.bmRequestType = *(setup_packet + 0),
         .bRequest = *(setup_packet + 1),
         .wValue = (unsigned short)(((int)*(setup_packet + 3) << 8) | (int)*(
                                    setup_packet + 2)),
         .wIndex = (unsigned short)(((int)*(setup_packet + 5) << 8) | (int)*(
                                    setup_packet + 4)),
         .wLength = (unsigned short)(((int)*(setup_packet + 7) << 8) | (int)*(
                                     setup_packet + 6))};
      errcode = usbctrl_handle_requests(& formated_pkt,dev_id);
      __retres = errcode;
      goto return_label;
    }
    else usb_backend_drv_stall(ep,USB_BACKEND_DRV_EP_DIR_OUT);
    break;
    case (mbed_error_t)USB_BACKEND_DRV_EP_STATE_DATA_OUT:
    {
      uint8_t curr_cfg = ctx->curr_cfg;
      if (size == (uint32_t)0) break;
      {
        uint8_t iface = (unsigned char)0;
        while ((int)iface < (int)ctx->cfg[curr_cfg].interface_num) {
          {
            uint8_t i = (unsigned char)0;
            while ((int)i < (int)ctx->cfg[curr_cfg].interfaces[iface].usb_ep_number) {
              if ((int)ctx->cfg[curr_cfg].interfaces[iface].eps[i].ep_num == (int)ep) 
                if (ctx->cfg[curr_cfg].interfaces[iface].eps[i].dir == (unsigned int)USB_EP_DIR_OUT) {
                  if (ctx->cfg[curr_cfg].interfaces[iface].eps[i].handler) {
                    (*(ctx->cfg[curr_cfg].interfaces[iface].eps[i].handler))
                    (dev_id,size,ep);
                    errcode = usb_backend_drv_set_recv_fifo(& ctx->ctrl_fifo[0],
                                                            (unsigned int)128,
                                                            (unsigned char)0);
                  }
                  goto err;
                }
              i = (uint8_t)((int)i + 1);
            }
          }
          iface = (uint8_t)((int)iface + 1);
        }
      }
      errcode = MBED_ERROR_INVSTATE;
      usb_backend_drv_nak(ep,USB_BACKEND_DRV_EP_DIR_OUT);
    }
    default: ;
    break;
  }
  err: ;
  __retres = errcode;
  return_label: return __retres;
}

mbed_error_t usbctrl_handle_wakeup(uint32_t dev_id)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  dev_id = dev_id;
  return errcode;
}

__inline static uint8_t min_u8_2(uint8_t x, uint8_t y)
{
  uint8_t __retres;
  if ((int)x < (int)y) {
    __retres = x;
    goto return_label;
  }
  else {
    __retres = y;
    goto return_label;
  }
  return_label: return __retres;
}

static uint32_t get_reg_value_2(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos);

static int8_t set_reg_value_2(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos);

static uint32_t read_reg_value_2(uint32_t volatile *reg);

static uint16_t read_reg16_value_2(uint16_t volatile *reg);

static void write_reg_value_2(uint32_t volatile *reg, uint32_t value);

static void write_reg16_value_2(uint16_t volatile *reg, uint16_t value);

static void set_reg_bits_2(uint32_t volatile *reg, uint32_t value);

static void clear_reg_bits_2(uint32_t volatile *reg, uint32_t value);

static uint32_t get_reg_value_2(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos)
{
  uint32_t __retres;
  if (mask == (uint32_t)0x00) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((int)pos > 31) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (*reg & mask) >> (int)pos;
  return_label: return __retres;
}

__inline static uint16_t get_reg16_value_2(uint16_t volatile *reg,
                                           uint16_t mask, uint8_t pos)
{
  uint16_t __retres;
  if ((int)mask == 0x00) {
    __retres = (unsigned short)0;
    goto return_label;
  }
  else 
    if ((int)pos > 15) {
      __retres = (unsigned short)0;
      goto return_label;
    }
  __retres = (unsigned short)(((int)*reg & (int)mask) >> (int)pos);
  return_label: return __retres;
}

static int8_t set_reg_value_2(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos)
{
  int8_t __retres;
  uint32_t tmp;
  if ((int)pos > 31) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if (mask == 0xFFFFFFFF) *reg = value;
  else {
    tmp = read_reg_value_2(reg);
    tmp &= ~ mask;
    tmp |= (value << (int)pos) & mask;
    write_reg_value_2(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

__inline static int8_t set_reg16_value_2(uint16_t volatile *reg,
                                         uint16_t value, uint16_t mask,
                                         uint8_t pos)
{
  int8_t __retres;
  uint16_t tmp;
  if ((int)pos > 15) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if ((int)mask == 0xFFFF) *reg = value;
  else {
    tmp = read_reg16_value_2(reg);
    tmp = (unsigned short)((int)tmp & (int)((unsigned short)(~ ((int)mask))));
    tmp = (unsigned short)((int)tmp | (int)((unsigned short)(((int)value << (int)pos) & (int)mask)));
    write_reg16_value_2(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

static uint32_t read_reg_value_2(uint32_t volatile *reg)
{
  uint32_t __retres;
  __retres = *reg;
  return __retres;
}

static uint16_t read_reg16_value_2(uint16_t volatile *reg)
{
  uint16_t __retres;
  __retres = *reg;
  return __retres;
}

static void write_reg_value_2(uint32_t volatile *reg, uint32_t value)
{
  *reg = value;
  return;
}

static void write_reg16_value_2(uint16_t volatile *reg, uint16_t value)
{
  *reg = value;
  return;
}

static void set_reg_bits_2(uint32_t volatile *reg, uint32_t value)
{
  *reg |= value;
  return;
}

__inline static void set_reg16_bits_2(uint16_t volatile *reg, uint16_t value)
{
  *reg = (unsigned short)((int)*reg | (int)value);
  return;
}

static void clear_reg_bits_2(uint32_t volatile *reg, uint32_t value)
{
  *reg &= ~ value;
  return;
}

__inline static usbctrl_req_type_t usbctrl_std_req_get_type(usbctrl_setup_pkt_t *pkt)
{
  usbctrl_req_type_t __retres;
  __retres = (enum __anonenum_usbctrl_req_type_t_93)(((int)pkt->bmRequestType >> 5) & 0x3);
  return __retres;
}

__inline static usbctrl_req_dir_t usbctrl_std_req_get_dir(usbctrl_setup_pkt_t *pkt)
{
  usbctrl_req_dir_t __retres;
  __retres = (enum __anonenum_usbctrl_req_dir_t_94)(((int)pkt->bmRequestType >> 7) & 0x1);
  return __retres;
}

__inline static usbctrl_req_recipient_t usbctrl_std_req_get_recipient
(usbctrl_setup_pkt_t *pkt)
{
  usbctrl_req_recipient_t __retres;
  __retres = (enum __anonenum_usbctrl_req_recipient_t_95)((int)pkt->bmRequestType & 0x1F);
  return __retres;
}

__inline static usbctrl_req_descriptor_type_t usbctrl_std_req_get_descriptor_type
(usbctrl_setup_pkt_t *pkt)
{
  usbctrl_req_descriptor_type_t val =
    (enum __anonenum_usbctrl_req_descriptor_type_t_96)((int)pkt->wValue >> 8);
  return val;
}

__inline static bool is_std_requests_allowed(usbctrl_context_t *ctx)
{
  bool __retres;
  usb_device_state_t tmp;
  tmp = usbctrl_get_state((usbctrl_context_t const *)ctx);
  if (tmp == (unsigned int)USB_DEVICE_STATE_DEFAULT) goto _LOR;
  else {
    usb_device_state_t tmp_0;
    tmp_0 = usbctrl_get_state((usbctrl_context_t const *)ctx);
    if (tmp_0 == (unsigned int)USB_DEVICE_STATE_ADDRESS) goto _LOR;
    else {
      usb_device_state_t tmp_1;
      tmp_1 = usbctrl_get_state((usbctrl_context_t const *)ctx);
      if (tmp_1 == (unsigned int)USB_DEVICE_STATE_CONFIGURED) {
        _LOR: {
                __retres = true;
                goto return_label;
              }
      }
    }
  }
  __retres = false;
  return_label: return __retres;
}

__inline static bool is_vendor_requests_allowed(usbctrl_context_t *ctx)
{
  bool __retres;
  usb_device_state_t tmp;
  tmp = usbctrl_get_state((usbctrl_context_t const *)ctx);
  if (tmp == (unsigned int)USB_DEVICE_STATE_DEFAULT) goto _LOR;
  else {
    usb_device_state_t tmp_0;
    tmp_0 = usbctrl_get_state((usbctrl_context_t const *)ctx);
    if (tmp_0 == (unsigned int)USB_DEVICE_STATE_ADDRESS) goto _LOR;
    else {
      usb_device_state_t tmp_1;
      tmp_1 = usbctrl_get_state((usbctrl_context_t const *)ctx);
      if (tmp_1 == (unsigned int)USB_DEVICE_STATE_CONFIGURED) {
        _LOR: {
                __retres = true;
                goto return_label;
              }
      }
    }
  }
  __retres = false;
  return_label: return __retres;
}

__inline static bool is_class_requests_allowed(usbctrl_context_t *ctx)
{
  bool __retres;
  usb_device_state_t tmp;
  tmp = usbctrl_get_state((usbctrl_context_t const *)ctx);
  if (tmp == (unsigned int)USB_DEVICE_STATE_CONFIGURED) {
    __retres = true;
    goto return_label;
  }
  __retres = false;
  return_label: return __retres;
}

static mbed_error_t usbctrl_std_req_handle_clear_feature(usbctrl_setup_pkt_t *pkt,
                                                         usbctrl_context_t *ctx)
{
  bool tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  pkt = pkt;
  ctx = ctx;
  ctx->ctrl_req_processing = false;
  err: ;
  return errcode;
}

static mbed_error_t usbctrl_std_req_handle_get_status(usbctrl_setup_pkt_t *pkt,
                                                      usbctrl_context_t *ctx)
{
  bool tmp;
  usb_device_state_t tmp_0;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  tmp_0 = usbctrl_get_state((usbctrl_context_t const *)ctx);
  switch (tmp_0) {
    usbctrl_req_recipient_t tmp_1;
    usbctrl_req_recipient_t tmp_3;
    case (usb_device_state_t)USB_DEVICE_STATE_DEFAULT:
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    ctx->ctrl_req_processing = false;
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_ADDRESS:
    tmp_1 = usbctrl_std_req_get_recipient(pkt);
    if (tmp_1 != (unsigned int)USB_REQ_RECIPIENT_ENDPOINT) {
      usbctrl_req_recipient_t tmp_2;
      tmp_2 = usbctrl_std_req_get_recipient(pkt);
      if (tmp_2 != (unsigned int)USB_REQ_RECIPIENT_INTERFACE) {
        usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
        ctx->ctrl_req_processing = false;
        goto err;
      }
    }
    if (((int)pkt->wIndex & 0xf) != 0) {
      usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
      ctx->ctrl_req_processing = false;
      goto err;
    }
    tmp_3 = usbctrl_std_req_get_recipient(pkt);
    switch (tmp_3) {
      case (usbctrl_req_recipient_t)USB_REQ_RECIPIENT_ENDPOINT:
      {
        bool tmp_4;
        int tmp_5;
        uint8_t epnum = (unsigned char)((int)pkt->wIndex & 0xf);
        tmp_4 = usbctrl_is_endpoint_exists(ctx,epnum);
        if (! tmp_4) {
          usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
          ctx->ctrl_req_processing = false;
          goto err;
        }
        uint8_t resp[2] = {(unsigned char)0};
        if ((int)pkt->wLength >= 2) tmp_5 = 2;
        else tmp_5 = (int)pkt->wLength;
        usb_backend_drv_send_data((uint8_t *)(& resp),(unsigned int)tmp_5,
                                  (unsigned char)EP0);
        usb_backend_drv_ack((unsigned char)0,USB_BACKEND_DRV_EP_DIR_OUT);
        break;
      }
      default:
      usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
      goto err;
    }
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_CONFIGURED: break;
    default: ctx->ctrl_req_processing = false;
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    break;
  }
  err: ;
  return errcode;
}

static mbed_error_t usbctrl_std_req_handle_get_interface(usbctrl_setup_pkt_t *pkt,
                                                         usbctrl_context_t *ctx)
{
  bool tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    ctx->ctrl_req_processing = false;
    goto err;
  }
  pkt = pkt;
  ctx = ctx;
  ctx->ctrl_req_processing = false;
  err: ;
  return errcode;
}

static mbed_error_t usbctrl_std_req_handle_set_address(usbctrl_setup_pkt_t *pkt,
                                                       usbctrl_context_t *ctx)
{
  bool tmp;
  usb_device_state_t tmp_0;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  tmp_0 = usbctrl_get_state((usbctrl_context_t const *)ctx);
  switch (tmp_0) {
    case (usb_device_state_t)USB_DEVICE_STATE_DEFAULT: ;
    if ((int)pkt->wValue != 0) {
      ctx->address = pkt->wValue;
      usbctrl_set_state((usbctrl_context_t volatile *)ctx,
                        USB_DEVICE_STATE_ADDRESS);
      usb_backend_drv_set_address(ctx->address);
    }
    usb_backend_drv_send_zlp((unsigned char)0);
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_ADDRESS: ;
    if ((int)pkt->wValue != 0) {
      ctx->address = pkt->wValue;
      usb_backend_drv_set_address(ctx->address);
    }
    else usbctrl_set_state((usbctrl_context_t volatile *)ctx,
                           USB_DEVICE_STATE_DEFAULT);
    usb_backend_drv_send_zlp((unsigned char)0);
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_CONFIGURED:
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    break;
    default:
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    break;
  }
  err: ctx->ctrl_req_processing = false;
  return errcode;
}

static mbed_error_t usbctrl_std_req_handle_get_configuration(usbctrl_setup_pkt_t *pkt,
                                                             usbctrl_context_t *ctx)
{
  uint8_t resp[1];
  bool tmp;
  usb_device_state_t tmp_0;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  tmp_0 = usbctrl_get_state((usbctrl_context_t const *)ctx);
  switch (tmp_0) {
    case (usb_device_state_t)USB_DEVICE_STATE_DEFAULT:
    resp[0] = (unsigned char)0;
    usb_backend_drv_send_data((uint8_t *)(& resp),(unsigned int)1,
                              (unsigned char)EP0);
    usb_backend_drv_ack((unsigned char)0,USB_BACKEND_DRV_EP_DIR_OUT);
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_ADDRESS:
    resp[0] = (unsigned char)0;
    usb_backend_drv_send_data((uint8_t *)(& resp),(unsigned int)1,
                              (unsigned char)EP0);
    usb_backend_drv_ack((unsigned char)0,USB_BACKEND_DRV_EP_DIR_OUT);
    break;
    case (usb_device_state_t)USB_DEVICE_STATE_CONFIGURED:
    resp[0] = (unsigned char)1;
    usb_backend_drv_send_data((uint8_t *)(& resp),(unsigned int)1,
                              (unsigned char)EP0);
    usb_backend_drv_ack((unsigned char)0,USB_BACKEND_DRV_EP_DIR_OUT);
    break;
    default:
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    ctx->ctrl_req_processing = false;
    break;
  }
  pkt = pkt;
  err: ;
  return errcode;
}

static mbed_error_t usbctrl_std_req_handle_set_configuration(usbctrl_setup_pkt_t *pkt,
                                                             usbctrl_context_t *ctx)
{
  mbed_error_t __retres;
  uint8_t requested_configuration;
  bool tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  usbctrl_set_state((usbctrl_context_t volatile *)ctx,
                    USB_DEVICE_STATE_CONFIGURED);
  requested_configuration = (unsigned char)pkt->wValue;
  if ((int)requested_configuration == 0) goto _LOR;
  else 
    if ((int)requested_configuration > (int)ctx->num_cfg) {
      _LOR: {
              errcode = MBED_ERROR_INVPARAM;
              goto err;
            }
    }
  ctx->curr_cfg = (unsigned char)((int)requested_configuration - 1);
  uint8_t curr_cfg = ctx->curr_cfg;
  {
    uint8_t iface = (unsigned char)0;
    while ((int)iface < (int)ctx->cfg[curr_cfg].interface_num) {
      {
        uint8_t i = (unsigned char)0;
        while ((int)i < (int)ctx->cfg[curr_cfg].interfaces[iface].usb_ep_number) {
          {
            usb_backend_drv_ep_dir_t dir;
            if (ctx->cfg[curr_cfg].interfaces[iface].eps[i].dir == (unsigned int)USB_EP_DIR_OUT) 
              dir = USB_BACKEND_DRV_EP_DIR_OUT;
            else dir = USB_BACKEND_DRV_EP_DIR_IN;
            if (ctx->cfg[curr_cfg].interfaces[iface].eps[i].type != (unsigned int)USB_EP_TYPE_CONTROL) {
              errcode = usb_backend_drv_configure_endpoint(ctx->cfg[curr_cfg].interfaces[iface].eps[i].ep_num,
                                                           (enum __anonenum_usb_backend_drv_ep_type_t_53)ctx->cfg[curr_cfg].interfaces[iface].eps[i].type,
                                                           dir,
                                                           (enum __anonenum_usb_backend_drv_epx_mpsize_t_55)ctx->cfg[curr_cfg].interfaces[iface].eps[i].pkt_maxsize,
                                                           USB_BACKEND_EP_ODDFRAME,
                                                           ctx->cfg[curr_cfg].interfaces[iface].eps[i].handler);
              if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
            }
            ctx->cfg[curr_cfg].interfaces[iface].eps[i].configured = true;
          }
          i = (uint8_t)((int)i + 1);
        }
      }
      iface = (uint8_t)((int)iface + 1);
    }
  }
  usbctrl_configuration_set();
  usb_backend_drv_send_zlp((unsigned char)0);
  pkt = pkt;
  ctx->ctrl_req_processing = false;
  __retres = errcode;
  goto return_label;
  err:
  usb_backend_drv_stall((unsigned char)0,
                        (enum __anonenum_usb_backend_drv_ep_dir_t_52)USB_EP_DIR_OUT);
  ctx->ctrl_req_processing = false;
  __retres = errcode;
  return_label: return __retres;
}

static mbed_error_t usbctrl_std_req_handle_get_descriptor(usbctrl_setup_pkt_t *pkt,
                                                          usbctrl_context_t *ctx)
{
  mbed_error_t __retres;
  usbctrl_req_descriptor_type_t desctype;
  uint16_t maxlength;
  bool tmp;
  uint8_t buf[256];
  mbed_error_t errcode = MBED_ERROR_NONE;
  bool send_zlp = false;
  send_zlp = send_zlp;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  desctype = usbctrl_std_req_get_descriptor_type(pkt);
  maxlength = pkt->wLength;
  if ((int)maxlength == 0) {
    ctx->ctrl_req_processing = false;
    goto err;
  }
  uint32_t size = (unsigned int)0;
  switch (desctype) {
    case (usbctrl_req_descriptor_type_t)USB_REQ_DESCRIPTOR_DEVICE: ;
    if ((int)pkt->wIndex != 0) {
      ctx->ctrl_req_processing = false;
      goto err;
    }
    if ((int)maxlength == 0) {
      errcode = usb_backend_drv_send_zlp((unsigned char)0);
      ctx->ctrl_req_processing = false;
    }
    else {
      errcode = usbctrl_get_descriptor(USB_DESC_DEVICE,buf,& size,ctx,pkt);
      if (errcode != (unsigned int)MBED_ERROR_NONE) {
        ctx->ctrl_req_processing = false;
        goto err;
      }
      if ((uint32_t)maxlength >= size) errcode = usb_backend_drv_send_data
                                       (buf,size,(unsigned char)0);
      else {
        errcode = usb_backend_drv_send_data(buf,(unsigned int)maxlength,
                                            (unsigned char)0);
        if (errcode != (unsigned int)MBED_ERROR_NONE) ;
      }
    }
    usb_backend_drv_ack((unsigned char)0,USB_BACKEND_DRV_EP_DIR_OUT);
    break;
    case (usbctrl_req_descriptor_type_t)USB_REQ_DESCRIPTOR_CONFIGURATION: ;
    if ((int)pkt->wIndex != 0) {
      ctx->ctrl_req_processing = false;
      goto err;
    }
    if ((int)maxlength == 0) {
      errcode = usb_backend_drv_send_zlp((unsigned char)0);
      ctx->ctrl_req_processing = false;
    }
    else {
      errcode = usbctrl_get_descriptor(USB_DESC_CONFIGURATION,buf,& size,ctx,
                                       pkt);
      if (errcode != (unsigned int)MBED_ERROR_NONE) {
        ctx->ctrl_req_processing = false;
        goto err;
      }
      usbctrl_set_state((usbctrl_context_t volatile *)ctx,
                        USB_DEVICE_STATE_CONFIGURED);
      if ((uint32_t)maxlength > size) errcode = usb_backend_drv_send_data
                                      (buf,size,(unsigned char)0);
      else errcode = usb_backend_drv_send_data(buf,(unsigned int)maxlength,
                                               (unsigned char)0);
    }
    usb_backend_drv_ack((unsigned char)0,USB_BACKEND_DRV_EP_DIR_OUT);
    break;
    case (usbctrl_req_descriptor_type_t)USB_REQ_DESCRIPTOR_STRING: ;
    errcode = usbctrl_get_descriptor(USB_DESC_STRING,buf,& size,ctx,pkt);
    if (errcode != (unsigned int)MBED_ERROR_NONE) {
      ctx->ctrl_req_processing = false;
      goto err;
    }
    if ((int)maxlength == 0) {
      errcode = usb_backend_drv_send_zlp((unsigned char)0);
      ctx->ctrl_req_processing = false;
    }
    else 
      if ((uint32_t)maxlength > size) errcode = usb_backend_drv_send_data
                                      (buf,size,(unsigned char)0);
      else errcode = usb_backend_drv_send_data(buf,(unsigned int)maxlength,
                                               (unsigned char)0);
    usb_backend_drv_ack((unsigned char)0,USB_BACKEND_DRV_EP_DIR_OUT);
    break;
    case (usbctrl_req_descriptor_type_t)USB_REQ_DESCRIPTOR_INTERFACE: ;
    if ((int)pkt->wIndex != 0) {
      ctx->ctrl_req_processing = false;
      goto err;
    }
    if ((int)maxlength == 0) {
      errcode = usb_backend_drv_send_zlp((unsigned char)0);
      ctx->ctrl_req_processing = false;
    }
    else {
      errcode = usbctrl_get_descriptor(USB_DESC_INTERFACE,buf,& size,ctx,pkt);
      if (errcode != (unsigned int)MBED_ERROR_NONE) {
        ctx->ctrl_req_processing = false;
        goto err;
      }
      if ((uint32_t)maxlength > size) errcode = usb_backend_drv_send_data
                                      (buf,size,(unsigned char)0);
      else errcode = usb_backend_drv_send_data(buf,(unsigned int)maxlength,
                                               (unsigned char)0);
    }
    usb_backend_drv_ack((unsigned char)0,USB_BACKEND_DRV_EP_DIR_OUT);
    break;
    case (usbctrl_req_descriptor_type_t)USB_REQ_DESCRIPTOR_ENDPOINT: ;
    if ((int)pkt->wIndex != 0) {
      ctx->ctrl_req_processing = false;
      goto err;
    }
    errcode = usbctrl_get_descriptor(USB_DESC_ENDPOINT,buf,& size,ctx,pkt);
    if (errcode != (unsigned int)MBED_ERROR_NONE) {
      ctx->ctrl_req_processing = false;
      goto err;
    }
    if ((uint32_t)maxlength > size) errcode = usb_backend_drv_send_data
                                    (buf,size,(unsigned char)0);
    else errcode = usb_backend_drv_send_data(buf,(unsigned int)maxlength,
                                             (unsigned char)0);
    usb_backend_drv_ack((unsigned char)0,USB_BACKEND_DRV_EP_DIR_OUT);
    break;
    case (usbctrl_req_descriptor_type_t)USB_REQ_DESCRIPTOR_DEVICE_QUALIFIER:
    ;
    if ((int)pkt->wIndex != 0) {
      ctx->ctrl_req_processing = false;
      goto err;
    }
    ctx->ctrl_req_processing = false;
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    break;
    case (usbctrl_req_descriptor_type_t)USB_REQ_DESCRIPTOR_OTHER_SPEED_CFG: ;
    if ((int)pkt->wIndex != 0) {
      ctx->ctrl_req_processing = false;
      goto err;
    }
    ctx->ctrl_req_processing = false;
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    break;
    case (usbctrl_req_descriptor_type_t)USB_REQ_DESCRIPTOR_INTERFACE_POWER: ;
    if ((int)pkt->wIndex != 0) {
      ctx->ctrl_req_processing = false;
      goto err;
    }
    ctx->ctrl_req_processing = false;
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    break;
    default: goto err;
    break;
  }
  __retres = errcode;
  goto return_label;
  err: usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
  __retres = errcode;
  return_label: return __retres;
}

static mbed_error_t usbctrl_std_req_handle_set_descriptor(usbctrl_setup_pkt_t *pkt __attribute__((
                                                          __unused__)),
                                                          usbctrl_context_t *ctx)
{
  bool tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    ctx->ctrl_req_processing = false;
    goto err;
  }
  usb_backend_drv_send_zlp((unsigned char)0);
  ctx->ctrl_req_processing = false;
  err: ;
  return errcode;
}

static mbed_error_t usbctrl_std_req_handle_set_feature(usbctrl_setup_pkt_t *pkt,
                                                       usbctrl_context_t *ctx)
{
  bool tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    ctx->ctrl_req_processing = false;
    goto err;
  }
  pkt = pkt;
  usb_backend_drv_send_zlp((unsigned char)0);
  ctx->ctrl_req_processing = false;
  err: ;
  return errcode;
}

static mbed_error_t usbctrl_std_req_handle_set_interface(usbctrl_setup_pkt_t *pkt,
                                                         usbctrl_context_t *ctx)
{
  bool tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  pkt = pkt;
  usb_backend_drv_send_zlp((unsigned char)0);
  err: ctx->ctrl_req_processing = false;
  return errcode;
}

static mbed_error_t usbctrl_std_req_handle_synch_frame(usbctrl_setup_pkt_t *pkt,
                                                       usbctrl_context_t *ctx)
{
  bool tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_std_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  pkt = pkt;
  usb_backend_drv_send_zlp((unsigned char)0);
  err: ;
  return errcode;
}

__inline static mbed_error_t usbctrl_handle_std_requests(usbctrl_setup_pkt_t *pkt,
                                                         usbctrl_context_t *ctx)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  switch ((int)pkt->bRequest) {
    case USB_REQ_GET_STATUS:
    errcode = usbctrl_std_req_handle_get_status(pkt,ctx);
    break;
    case USB_REQ_CLEAR_FEATURE:
    errcode = usbctrl_std_req_handle_clear_feature(pkt,ctx);
    break;
    case USB_REQ_SET_FEATURE:
    errcode = usbctrl_std_req_handle_set_feature(pkt,ctx);
    break;
    case USB_REQ_SET_ADDRESS:
    errcode = usbctrl_std_req_handle_set_address(pkt,ctx);
    break;
    case USB_REQ_GET_DESCRIPTOR:
    errcode = usbctrl_std_req_handle_get_descriptor(pkt,ctx);
    break;
    case USB_REQ_SET_DESCRIPTOR:
    errcode = usbctrl_std_req_handle_set_descriptor(pkt,ctx);
    break;
    case USB_REQ_GET_CONFIGURATION:
    errcode = usbctrl_std_req_handle_get_configuration(pkt,ctx);
    break;
    case USB_REQ_SET_CONFIGURATION:
    errcode = usbctrl_std_req_handle_set_configuration(pkt,ctx);
    break;
    case USB_REQ_GET_INTERFACE:
    errcode = usbctrl_std_req_handle_get_interface(pkt,ctx);
    break;
    case USB_REQ_SET_INTERFACE:
    errcode = usbctrl_std_req_handle_set_interface(pkt,ctx);
    break;
    case USB_REQ_SYNCH_FRAME:
    errcode = usbctrl_std_req_handle_synch_frame(pkt,ctx);
    break;
    default: ;
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    break;
  }
  return errcode;
}

__inline static mbed_error_t usbctrl_handle_vendor_requests(usbctrl_setup_pkt_t *pkt,
                                                            usbctrl_context_t *ctx)
{
  bool tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = is_vendor_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  pkt = pkt;
  ctx->ctrl_req_processing = false;
  err: ;
  return errcode;
}

__inline static mbed_error_t usbctrl_handle_class_requests(usbctrl_setup_pkt_t *pkt,
                                                           usbctrl_context_t *ctx)
{
  bool tmp;
  bool tmp_0;
  uint32_t handler;
  mbed_error_t tmp_1;
  mbed_error_t errcode = MBED_ERROR_NONE;
  uint8_t iface_idx = (unsigned char)0;
  usbctrl_interface_t *iface = (usbctrl_interface_t *)0;
  tmp = is_class_requests_allowed(ctx);
  if (! tmp) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  iface_idx = (unsigned char)(((int)pkt->wIndex & 0xff) - 1);
  tmp_0 = usbctrl_is_interface_exists(ctx,iface_idx);
  if (! tmp_0) {
    errcode = MBED_ERROR_NOTFOUND;
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    goto err;
  }
  iface = usbctrl_get_interface(ctx,iface_idx);
  if (iface == (usbctrl_interface_t *)0) {
    errcode = MBED_ERROR_UNKNOWN;
    usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
    goto err;
  }
  tmp_1 = usbctrl_get_handler(ctx,& handler);
  if (tmp_1 != (unsigned int)MBED_ERROR_NONE) ;
  errcode = (*(iface->rqst_handler))(handler,pkt);
  err: ;
  return errcode;
}

__inline static mbed_error_t usbctrl_handle_unknown_requests(usbctrl_setup_pkt_t *pkt,
                                                             usbctrl_context_t *ctx)
{
  mbed_error_t __retres;
  ctx = ctx;
  pkt = pkt;
  usb_backend_drv_stall((unsigned char)EP0,USB_BACKEND_DRV_EP_DIR_IN);
  __retres = MBED_ERROR_UNKNOWN;
  return __retres;
}

mbed_error_t usbctrl_handle_requests(usbctrl_setup_pkt_t *pkt,
                                     uint32_t dev_id)
{
  mbed_error_t tmp;
  usbctrl_req_type_t tmp_4;
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbctrl_context_t *ctx = (usbctrl_context_t *)0;
  if (pkt == (usbctrl_setup_pkt_t *)0) {
    errcode = MBED_ERROR_INVPARAM;
    usb_backend_drv_stall((unsigned char)EP0,
                          (enum __anonenum_usb_backend_drv_ep_dir_t_52)USB_EP_DIR_OUT);
    goto err;
  }
  tmp = usbctrl_get_context(dev_id,& ctx);
  if (tmp != (unsigned int)MBED_ERROR_NONE) {
    errcode = MBED_ERROR_UNKNOWN;
    usb_backend_drv_stall((unsigned char)EP0,
                          (enum __anonenum_usb_backend_drv_ep_dir_t_52)USB_EP_DIR_OUT);
    goto err;
  }
  tmp_4 = usbctrl_std_req_get_type(pkt);
  if (tmp_4 == (unsigned int)USB_REQ_TYPE_STD) {
    usbctrl_req_recipient_t tmp_5;
    tmp_5 = usbctrl_std_req_get_recipient(pkt);
    if (tmp_5 != (unsigned int)USB_REQ_RECIPIENT_INTERFACE) {
      ctx->ctrl_req_processing = true;
      errcode = usbctrl_handle_std_requests(pkt,ctx);
    }
    else goto _LAND;
  }
  else {
    usbctrl_req_type_t tmp_3;
    _LAND: tmp_3 = usbctrl_std_req_get_type(pkt);
    if (tmp_3 == (unsigned int)USB_REQ_TYPE_VENDOR) {
      ctx->ctrl_req_processing = true;
      errcode = usbctrl_handle_vendor_requests(pkt,ctx);
    }
    else {
      usbctrl_req_type_t tmp_1;
      tmp_1 = usbctrl_std_req_get_type(pkt);
      if (tmp_1 == (unsigned int)USB_REQ_TYPE_CLASS) goto _LOR;
      else {
        usbctrl_req_recipient_t tmp_2;
        tmp_2 = usbctrl_std_req_get_recipient(pkt);
        if (tmp_2 == (unsigned int)USB_REQ_RECIPIENT_INTERFACE) {
          _LOR:
          {
            uint8_t curr_cfg = ctx->curr_cfg;
            mbed_error_t upper_stack_err = MBED_ERROR_INVPARAM;
            {
              uint8_t i = (unsigned char)0;
              while ((int)i < (int)ctx->cfg[curr_cfg].interface_num) {
                if (ctx->cfg[curr_cfg].interfaces[i].rqst_handler) {
                  uint32_t handler;
                  mbed_error_t tmp_0;
                  tmp_0 = usbctrl_get_handler(ctx,& handler);
                  if (tmp_0 != (unsigned int)MBED_ERROR_NONE) ;
                  upper_stack_err = (*(ctx->cfg[curr_cfg].interfaces[i].rqst_handler))
                  (handler,pkt);
                  if (upper_stack_err == (unsigned int)MBED_ERROR_NONE) 
                    break;
                }
                i = (uint8_t)((int)i + 1);
              }
            }
            if (upper_stack_err != (unsigned int)MBED_ERROR_NONE) usb_backend_drv_stall
                                                                  ((unsigned char)0,
                                                                   (enum __anonenum_usb_backend_drv_ep_dir_t_52)USB_EP_DIR_OUT);
          }
        }
        else errcode = usbctrl_handle_unknown_requests(pkt,ctx);
      }
    }
  }
  err:
  ctx->ctrl_fifo_state = (enum __anonenum_bool_1)USB_CTRL_RCV_FIFO_SATE_FREE;
  return errcode;
}

__inline static uint8_t min_u8_3(uint8_t x, uint8_t y)
{
  uint8_t __retres;
  if ((int)x < (int)y) {
    __retres = x;
    goto return_label;
  }
  else {
    __retres = y;
    goto return_label;
  }
  return_label: return __retres;
}

static uint32_t get_reg_value_3(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos);

static int8_t set_reg_value_3(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos);

static uint32_t read_reg_value_3(uint32_t volatile *reg);

static uint16_t read_reg16_value_3(uint16_t volatile *reg);

static void write_reg_value_3(uint32_t volatile *reg, uint32_t value);

static void write_reg16_value_3(uint16_t volatile *reg, uint16_t value);

static void set_reg_bits_3(uint32_t volatile *reg, uint32_t value);

static void clear_reg_bits_3(uint32_t volatile *reg, uint32_t value);

static uint32_t get_reg_value_3(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos)
{
  uint32_t __retres;
  if (mask == (uint32_t)0x00) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((int)pos > 31) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (*reg & mask) >> (int)pos;
  return_label: return __retres;
}

__inline static uint16_t get_reg16_value_3(uint16_t volatile *reg,
                                           uint16_t mask, uint8_t pos)
{
  uint16_t __retres;
  if ((int)mask == 0x00) {
    __retres = (unsigned short)0;
    goto return_label;
  }
  else 
    if ((int)pos > 15) {
      __retres = (unsigned short)0;
      goto return_label;
    }
  __retres = (unsigned short)(((int)*reg & (int)mask) >> (int)pos);
  return_label: return __retres;
}

static int8_t set_reg_value_3(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos)
{
  int8_t __retres;
  uint32_t tmp;
  if ((int)pos > 31) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if (mask == 0xFFFFFFFF) *reg = value;
  else {
    tmp = read_reg_value_3(reg);
    tmp &= ~ mask;
    tmp |= (value << (int)pos) & mask;
    write_reg_value_3(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

__inline static int8_t set_reg16_value_3(uint16_t volatile *reg,
                                         uint16_t value, uint16_t mask,
                                         uint8_t pos)
{
  int8_t __retres;
  uint16_t tmp;
  if ((int)pos > 15) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if ((int)mask == 0xFFFF) *reg = value;
  else {
    tmp = read_reg16_value_3(reg);
    tmp = (unsigned short)((int)tmp & (int)((unsigned short)(~ ((int)mask))));
    tmp = (unsigned short)((int)tmp | (int)((unsigned short)(((int)value << (int)pos) & (int)mask)));
    write_reg16_value_3(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

static uint32_t read_reg_value_3(uint32_t volatile *reg)
{
  uint32_t __retres;
  __retres = *reg;
  return __retres;
}

static uint16_t read_reg16_value_3(uint16_t volatile *reg)
{
  uint16_t __retres;
  __retres = *reg;
  return __retres;
}

static void write_reg_value_3(uint32_t volatile *reg, uint32_t value)
{
  *reg = value;
  return;
}

static void write_reg16_value_3(uint16_t volatile *reg, uint16_t value)
{
  *reg = value;
  return;
}

static void set_reg_bits_3(uint32_t volatile *reg, uint32_t value)
{
  *reg |= value;
  return;
}

__inline static void set_reg16_bits_3(uint16_t volatile *reg, uint16_t value)
{
  *reg = (unsigned short)((int)*reg | (int)value);
  return;
}

static void clear_reg_bits_3(uint32_t volatile *reg, uint32_t value)
{
  *reg &= ~ value;
  return;
}

static struct __anonstruct_usb_automaton_84 const usb_automaton[10] =
  {{.state = USB_DEVICE_STATE_ATTACHED,
    .req_trans = {{.request = (unsigned char)USB_DEVICE_TRANS_HUB_CONFIGURED,
                   .target_state = (unsigned char)USB_DEVICE_STATE_POWERED},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}},
   {.state = USB_DEVICE_STATE_POWERED,
    .req_trans = {{.request = (unsigned char)USB_DEVICE_TRANS_BUS_INACTIVE,
                   .target_state = (unsigned char)USB_DEVICE_STATE_SUSPENDED_POWER},
                  {.request = (unsigned char)USB_DEVICE_TRANS_HUB_RESET,
                   .target_state = (unsigned char)USB_DEVICE_STATE_ATTACHED},
                  {.request = (unsigned char)USB_DEVICE_TRANS_HUB_DECONFIGURED,
                   .target_state = (unsigned char)USB_DEVICE_STATE_ATTACHED},
                  {.request = (unsigned char)USB_DEVICE_TRANS_RESET,
                   .target_state = (unsigned char)USB_DEVICE_STATE_DEFAULT},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}},
   {.state = USB_DEVICE_STATE_SUSPENDED_POWER,
    .req_trans = {{.request = (unsigned char)USB_DEVICE_TRANS_BUS_ACTIVE,
                   .target_state = (unsigned char)USB_DEVICE_STATE_POWERED},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}},
   {.state = USB_DEVICE_STATE_SUSPENDED_DEFAULT,
    .req_trans = {{.request = (unsigned char)USB_DEVICE_TRANS_BUS_ACTIVE,
                   .target_state = (unsigned char)USB_DEVICE_STATE_DEFAULT},
                  {.request = (unsigned char)USB_DEVICE_TRANS_RESET,
                   .target_state = (unsigned char)USB_DEVICE_STATE_DEFAULT},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}},
   {.state = USB_DEVICE_STATE_SUSPENDED_ADDRESS,
    .req_trans = {{.request = (unsigned char)USB_DEVICE_TRANS_BUS_ACTIVE,
                   .target_state = (unsigned char)USB_DEVICE_STATE_ADDRESS},
                  {.request = (unsigned char)USB_DEVICE_TRANS_RESET,
                   .target_state = (unsigned char)USB_DEVICE_STATE_DEFAULT},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}},
   {.state = USB_DEVICE_STATE_SUSPENDED_CONFIGURED,
    .req_trans = {{.request = (unsigned char)USB_DEVICE_TRANS_BUS_ACTIVE,
                   .target_state = (unsigned char)USB_DEVICE_STATE_CONFIGURED},
                  {.request = (unsigned char)USB_DEVICE_TRANS_RESET,
                   .target_state = (unsigned char)USB_DEVICE_STATE_DEFAULT},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}},
   {.state = USB_DEVICE_STATE_DEFAULT,
    .req_trans = {{.request = (unsigned char)USB_DEVICE_TRANS_ADDRESS_ASSIGNED,
                   .target_state = (unsigned char)USB_DEVICE_STATE_ADDRESS},
                  {.request = (unsigned char)USB_DEVICE_TRANS_BUS_INACTIVE,
                   .target_state = (unsigned char)USB_DEVICE_STATE_SUSPENDED_DEFAULT},
                  {.request = (unsigned char)USB_DEVICE_TRANS_RESET,
                   .target_state = (unsigned char)USB_DEVICE_STATE_DEFAULT},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}},
   {.state = USB_DEVICE_STATE_ADDRESS,
    .req_trans = {{.request = (unsigned char)USB_DEVICE_TRANS_DEV_CONFIGURED,
                   .target_state = (unsigned char)USB_DEVICE_STATE_CONFIGURED},
                  {.request = (unsigned char)USB_DEVICE_TRANS_BUS_INACTIVE,
                   .target_state = (unsigned char)USB_DEVICE_STATE_SUSPENDED_ADDRESS},
                  {.request = (unsigned char)USB_DEVICE_TRANS_RESET,
                   .target_state = (unsigned char)USB_DEVICE_STATE_DEFAULT},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}},
   {.state = USB_DEVICE_STATE_CONFIGURED,
    .req_trans = {{.request = (unsigned char)USB_DEVICE_TRANS_DEV_DECONFIGURED,
                   .target_state = (unsigned char)USB_DEVICE_STATE_ADDRESS},
                  {.request = (unsigned char)USB_DEVICE_TRANS_BUS_INACTIVE,
                   .target_state = (unsigned char)USB_DEVICE_STATE_SUSPENDED_CONFIGURED},
                  {.request = (unsigned char)USB_DEVICE_TRANS_RESET,
                   .target_state = (unsigned char)USB_DEVICE_STATE_DEFAULT},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}},
   {.state = USB_DEVICE_STATE_INVALID,
    .req_trans = {{.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff},
                  {.request = (unsigned char)0xff,
                   .target_state = (unsigned char)0xff}}}};
usb_device_state_t usbctrl_get_state(usbctrl_context_t const *ctx)
{
  usb_device_state_t __retres;
  if (ctx == (usbctrl_context_t const *)0) {
    __retres = USB_DEVICE_STATE_INVALID;
    goto return_label;
  }
  __retres = (enum __anonenum_usb_device_state_t_82)ctx->state;
  return_label: return __retres;
}

mbed_error_t usbctrl_set_state(usbctrl_context_t volatile *ctx,
                               usb_device_state_t newstate)
{
  mbed_error_t __retres;
  if (ctx == (usbctrl_context_t volatile *)0) {
    __retres = MBED_ERROR_INVPARAM;
    goto return_label;
  }
  if (newstate >= (unsigned int)USB_DEVICE_STATE_INVALID) {
    __retres = MBED_ERROR_INVPARAM;
    goto return_label;
  }
  ctx->state = (unsigned char)newstate;
  __retres = MBED_ERROR_NONE;
  return_label: return __retres;
}

uint8_t usbctrl_next_state(usb_device_state_t current_state,
                           usbctrl_request_code_t request)
{
  uint8_t __retres;
  {
    uint8_t i = (unsigned char)0;
    while ((int)i < 10) {
      if ((unsigned int)usb_automaton[current_state].req_trans[i].request == request) {
        __retres = usb_automaton[current_state].req_trans[i].target_state;
        goto return_label;
      }
      i = (uint8_t)((int)i + 1);
    }
  }
  __retres = (unsigned char)0xff;
  return_label: return __retres;
}

bool usbctrl_is_valid_transition(usb_device_state_t current_state,
                                 usb_device_trans_t transition,
                                 usbctrl_context_t *ctx)
{
  bool __retres;
  {
    uint8_t i = (unsigned char)0;
    while ((int)i < 10) {
      if ((unsigned int)usb_automaton[current_state].req_trans[i].request == transition) {
        __retres = true;
        goto return_label;
      }
      i = (uint8_t)((int)i + 1);
    }
  }
  usbctrl_set_state((usbctrl_context_t volatile *)ctx,
                    USB_DEVICE_STATE_INVALID);
  __retres = false;
  return_label: return __retres;
}

__inline static uint8_t min_u8_4(uint8_t x, uint8_t y)
{
  uint8_t __retres;
  if ((int)x < (int)y) {
    __retres = x;
    goto return_label;
  }
  else {
    __retres = y;
    goto return_label;
  }
  return_label: return __retres;
}

static uint32_t get_reg_value_4(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos);

static int8_t set_reg_value_4(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos);

static uint32_t read_reg_value_4(uint32_t volatile *reg);

static uint16_t read_reg16_value_4(uint16_t volatile *reg);

static void write_reg_value_4(uint32_t volatile *reg, uint32_t value);

static void write_reg16_value_4(uint16_t volatile *reg, uint16_t value);

static void set_reg_bits_4(uint32_t volatile *reg, uint32_t value);

static void clear_reg_bits_4(uint32_t volatile *reg, uint32_t value);

static uint32_t get_reg_value_4(uint32_t const volatile *reg, uint32_t mask,
                                uint8_t pos)
{
  uint32_t __retres;
  if (mask == (uint32_t)0x00) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((int)pos > 31) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (*reg & mask) >> (int)pos;
  return_label: return __retres;
}

__inline static uint16_t get_reg16_value_4(uint16_t volatile *reg,
                                           uint16_t mask, uint8_t pos)
{
  uint16_t __retres;
  if ((int)mask == 0x00) {
    __retres = (unsigned short)0;
    goto return_label;
  }
  else 
    if ((int)pos > 15) {
      __retres = (unsigned short)0;
      goto return_label;
    }
  __retres = (unsigned short)(((int)*reg & (int)mask) >> (int)pos);
  return_label: return __retres;
}

static int8_t set_reg_value_4(uint32_t volatile *reg, uint32_t value,
                              uint32_t mask, uint8_t pos)
{
  int8_t __retres;
  uint32_t tmp;
  if ((int)pos > 31) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if (mask == 0xFFFFFFFF) *reg = value;
  else {
    tmp = read_reg_value_4(reg);
    tmp &= ~ mask;
    tmp |= (value << (int)pos) & mask;
    write_reg_value_4(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

__inline static int8_t set_reg16_value_4(uint16_t volatile *reg,
                                         uint16_t value, uint16_t mask,
                                         uint8_t pos)
{
  int8_t __retres;
  uint16_t tmp;
  if ((int)pos > 15) {
    __retres = (signed char)(-1);
    goto return_label;
  }
  if ((int)mask == 0xFFFF) *reg = value;
  else {
    tmp = read_reg16_value_4(reg);
    tmp = (unsigned short)((int)tmp & (int)((unsigned short)(~ ((int)mask))));
    tmp = (unsigned short)((int)tmp | (int)((unsigned short)(((int)value << (int)pos) & (int)mask)));
    write_reg16_value_4(reg,tmp);
  }
  __retres = (signed char)0;
  return_label: return __retres;
}

static uint32_t read_reg_value_4(uint32_t volatile *reg)
{
  uint32_t __retres;
  __retres = *reg;
  return __retres;
}

static uint16_t read_reg16_value_4(uint16_t volatile *reg)
{
  uint16_t __retres;
  __retres = *reg;
  return __retres;
}

static void write_reg_value_4(uint32_t volatile *reg, uint32_t value)
{
  *reg = value;
  return;
}

static void write_reg16_value_4(uint16_t volatile *reg, uint16_t value)
{
  *reg = value;
  return;
}

static void set_reg_bits_4(uint32_t volatile *reg, uint32_t value)
{
  *reg |= value;
  return;
}

__inline static void set_reg16_bits_4(uint16_t volatile *reg, uint16_t value)
{
  *reg = (unsigned short)((int)*reg | (int)value);
  return;
}

static void clear_reg_bits_4(uint32_t volatile *reg, uint32_t value)
{
  *reg &= ~ value;
  return;
}

static struct user_driver_device_infos const usb_otg_hs_dev_infos_4 =
  {.address = (unsigned int)0x40040000,
   .size = (unsigned int)0x4000,
   .id = (unsigned int)7,
   .gpios = {{.port = (unsigned char)0, .pin = (unsigned char)3},
             {.port = (unsigned char)0, .pin = (unsigned char)5},
             {.port = (unsigned char)1, .pin = (unsigned char)0},
             {.port = (unsigned char)1, .pin = (unsigned char)1},
             {.port = (unsigned char)1, .pin = (unsigned char)10},
             {.port = (unsigned char)1, .pin = (unsigned char)11},
             {.port = (unsigned char)1, .pin = (unsigned char)12},
             {.port = (unsigned char)1, .pin = (unsigned char)13},
             {.port = (unsigned char)1, .pin = (unsigned char)5},
             {.port = (unsigned char)2, .pin = (unsigned char)0},
             {.port = (unsigned char)2, .pin = (unsigned char)2},
             {.port = (unsigned char)2, .pin = (unsigned char)3},
             {.port = (unsigned char)2, .pin = (unsigned char)1},
             {.port = (unsigned char)0, .pin = (unsigned char)0}}};
mbed_error_t usbotghs_initialize_core(usbotghs_dev_mode_t mode);

mbed_error_t usbotghs_initialize_device(void);

mbed_error_t usbotghs_initialize_host(void);

mbed_error_t usbotghs_reset_epx_fifo(usbotghs_ep_t *ep);

mbed_error_t usbotghs_write_epx_fifo(uint32_t size, usbotghs_ep_t *ep);

mbed_error_t usbotghs_set_xmit_fifo(uint8_t *src, uint32_t size, uint8_t epid);

void USBOTGHS_IRQHandler(uint8_t interrupt, uint32_t sr, uint32_t dr);

mbed_error_t usbotghs_ulpi_reset(void);

static void usbotghs_wait_for_xmit_complete(usbotghs_ep_t *ep)
{
  while (ep->state != (unsigned int)USBOTG_HS_EP_STATE_IDLE) ;
  return;
}

static char const *devname = "usb-otg-hs";
static usbotghs_context_t volatile usbotghs_ctx =
  {.dev = {.name = {(char)0},
           .address = 0U,
           .size = 0U,
           .irq_num = (unsigned char)0,
           .gpio_num = (unsigned char)0,
           .map_mode = 0,
           .irqs = {{.handler = (void (*)(uint8_t irq, uint32_t status,
                                          uint32_t data))0,
                     .irq = (unsigned char)0,
                     .mode = 0,
                     .posthook = {.action = {{.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}}},
                                  .status = 0U,
                                  .data = 0U}},
                    {.handler = (void (*)(uint8_t irq, uint32_t status,
                                          uint32_t data))0,
                     .irq = (unsigned char)0,
                     .mode = 0,
                     .posthook = {.action = {{.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}}},
                                  .status = 0U,
                                  .data = 0U}},
                    {.handler = (void (*)(uint8_t irq, uint32_t status,
                                          uint32_t data))0,
                     .irq = (unsigned char)0,
                     .mode = 0,
                     .posthook = {.action = {{.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}}},
                                  .status = 0U,
                                  .data = 0U}},
                    {.handler = (void (*)(uint8_t irq, uint32_t status,
                                          uint32_t data))0,
                     .irq = (unsigned char)0,
                     .mode = 0,
                     .posthook = {.action = {{.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}},
                                             {.instr = 0,
                                              .__anonCompField2 = {.read = {
                                                                   .offset = 0U,
                                                                   .value = 0U}}}},
                                  .status = 0U,
                                  .data = 0U}}},
           .gpios = {{.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0},
                     {.mask = 0,
                      .kref = {.__anonCompField1 = {.pin = (unsigned char)0,
                                                    .port = (unsigned char)0}},
                      .mode = 0,
                      .pupd = 0,
                      .type = 0,
                      .speed = 0,
                      .afr = 0U,
                      .bsr_r = 0U,
                      .bsr_s = 0U,
                      .lck = 0U,
                      .exti_trigger = 0,
                      .exti_lock = 0,
                      .exti_handler = (void (*)(uint8_t irq, uint32_t status,
                                                uint32_t data))0}}},
   .dev_desc = 0,
   .mode = 0,
   .gonak_req = 0,
   .gonak_active = 0,
   .fifo_idx = (unsigned short)0,
   .in_eps = {{.id = (unsigned char)0,
               .configured = 0,
               .mpsize = (unsigned short)0,
               .type = 0,
               .state = 0,
               .dir = 0,
               .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                            uint8_t ep))0,
               .fifo = (uint8_t volatile *)0,
               .fifo_idx = 0U,
               .fifo_size = 0U,
               .fifo_lck = 0,
               .core_txfifo_empty = 0},
              {.id = (unsigned char)0,
               .configured = 0,
               .mpsize = (unsigned short)0,
               .type = 0,
               .state = 0,
               .dir = 0,
               .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                            uint8_t ep))0,
               .fifo = (uint8_t volatile *)0,
               .fifo_idx = 0U,
               .fifo_size = 0U,
               .fifo_lck = 0,
               .core_txfifo_empty = 0},
              {.id = (unsigned char)0,
               .configured = 0,
               .mpsize = (unsigned short)0,
               .type = 0,
               .state = 0,
               .dir = 0,
               .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                            uint8_t ep))0,
               .fifo = (uint8_t volatile *)0,
               .fifo_idx = 0U,
               .fifo_size = 0U,
               .fifo_lck = 0,
               .core_txfifo_empty = 0},
              {.id = (unsigned char)0,
               .configured = 0,
               .mpsize = (unsigned short)0,
               .type = 0,
               .state = 0,
               .dir = 0,
               .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                            uint8_t ep))0,
               .fifo = (uint8_t volatile *)0,
               .fifo_idx = 0U,
               .fifo_size = 0U,
               .fifo_lck = 0,
               .core_txfifo_empty = 0},
              {.id = (unsigned char)0,
               .configured = 0,
               .mpsize = (unsigned short)0,
               .type = 0,
               .state = 0,
               .dir = 0,
               .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                            uint8_t ep))0,
               .fifo = (uint8_t volatile *)0,
               .fifo_idx = 0U,
               .fifo_size = 0U,
               .fifo_lck = 0,
               .core_txfifo_empty = 0},
              {.id = (unsigned char)0,
               .configured = 0,
               .mpsize = (unsigned short)0,
               .type = 0,
               .state = 0,
               .dir = 0,
               .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                            uint8_t ep))0,
               .fifo = (uint8_t volatile *)0,
               .fifo_idx = 0U,
               .fifo_size = 0U,
               .fifo_lck = 0,
               .core_txfifo_empty = 0},
              {.id = (unsigned char)0,
               .configured = 0,
               .mpsize = (unsigned short)0,
               .type = 0,
               .state = 0,
               .dir = 0,
               .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                            uint8_t ep))0,
               .fifo = (uint8_t volatile *)0,
               .fifo_idx = 0U,
               .fifo_size = 0U,
               .fifo_lck = 0,
               .core_txfifo_empty = 0},
              {.id = (unsigned char)0,
               .configured = 0,
               .mpsize = (unsigned short)0,
               .type = 0,
               .state = 0,
               .dir = 0,
               .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                            uint8_t ep))0,
               .fifo = (uint8_t volatile *)0,
               .fifo_idx = 0U,
               .fifo_size = 0U,
               .fifo_lck = 0,
               .core_txfifo_empty = 0}},
   .out_eps = {{.id = (unsigned char)0,
                .configured = 0,
                .mpsize = (unsigned short)0,
                .type = 0,
                .state = 0,
                .dir = 0,
                .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                             uint8_t ep))0,
                .fifo = (uint8_t volatile *)0,
                .fifo_idx = 0U,
                .fifo_size = 0U,
                .fifo_lck = 0,
                .core_txfifo_empty = 0},
               {.id = (unsigned char)0,
                .configured = 0,
                .mpsize = (unsigned short)0,
                .type = 0,
                .state = 0,
                .dir = 0,
                .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                             uint8_t ep))0,
                .fifo = (uint8_t volatile *)0,
                .fifo_idx = 0U,
                .fifo_size = 0U,
                .fifo_lck = 0,
                .core_txfifo_empty = 0},
               {.id = (unsigned char)0,
                .configured = 0,
                .mpsize = (unsigned short)0,
                .type = 0,
                .state = 0,
                .dir = 0,
                .handler = (mbed_error_t (*)(uint32_t dev_id, uint32_t size,
                                             uint8_t ep))0,
                .fifo = (uint8_t volatile *)0,
                .fifo_idx = 0U,
                .fifo_size = 0U,
                .fifo_lck = 0,
                .core_txfifo_empty = 0}},
   .speed = 0};
usbotghs_context_t *usbotghs_get_context(void)
{
  usbotghs_context_t *__retres;
  __retres = (usbotghs_context_t *)(& usbotghs_ctx);
  return __retres;
}

mbed_error_t usbotghs_declare(void)
{
  mbed_error_t __retres;
  uint32_t tmp;
  e_syscall_ret tmp_0;
  e_syscall_ret ret = (enum __anonenum_e_syscall_ret_12)0;
  memset((void *)(& usbotghs_ctx.dev),0,sizeof(device_t));
  tmp = strlen(devname);
  ;
  ;
  memcpy((void *)(usbotghs_ctx.dev.name),(void const *)devname,tmp);
  usbotghs_ctx.dev.address = (unsigned int)0x40040000;
  usbotghs_ctx.dev.size = (unsigned int)0x4000;
  usbotghs_ctx.dev.irq_num = (unsigned char)1;
  usbotghs_ctx.dev.map_mode = DEV_MAP_VOLUNTARY;
  usbotghs_ctx.dev.irqs[0].handler = & USBOTGHS_IRQHandler;
  usbotghs_ctx.dev.irqs[0].irq = (unsigned char)93;
  usbotghs_ctx.dev.irqs[0].mode = IRQ_ISR_FORCE_MAINTHREAD;
  usbotghs_ctx.dev.irqs[0].posthook.status = (unsigned int)0x0014;
  usbotghs_ctx.dev.irqs[0].posthook.data = (unsigned int)0x0018;
  usbotghs_ctx.dev.irqs[0].posthook.action[0].instr = IRQ_PH_READ;
  usbotghs_ctx.dev.irqs[0].posthook.action[0].__anonCompField2.read.offset = (unsigned int)0x0014;
  usbotghs_ctx.dev.irqs[0].posthook.action[1].instr = IRQ_PH_READ;
  usbotghs_ctx.dev.irqs[0].posthook.action[1].__anonCompField2.read.offset = (unsigned int)0x0018;
  usbotghs_ctx.dev.irqs[0].posthook.action[2].instr = IRQ_PH_MASK;
  usbotghs_ctx.dev.irqs[0].posthook.action[2].__anonCompField2.mask.offset_dest = (unsigned int)0x14;
  usbotghs_ctx.dev.irqs[0].posthook.action[2].__anonCompField2.mask.offset_src = (unsigned int)0x14;
  usbotghs_ctx.dev.irqs[0].posthook.action[2].__anonCompField2.mask.offset_mask = (unsigned int)0x18;
  usbotghs_ctx.dev.irqs[0].posthook.action[2].__anonCompField2.mask.mode = (unsigned char)0;
  usbotghs_ctx.dev.irqs[0].posthook.action[3].instr = IRQ_PH_AND;
  usbotghs_ctx.dev.irqs[0].posthook.action[3].__anonCompField2.and.offset_dest = (unsigned int)0x18;
  usbotghs_ctx.dev.irqs[0].posthook.action[3].__anonCompField2.and.offset_src = (unsigned int)0x14;
  usbotghs_ctx.dev.irqs[0].posthook.action[3].__anonCompField2.and.mask = 
  ((((unsigned int)1 << 19) | ((unsigned int)1 << 18)) | ((unsigned int)1 << 26)) | (
  (unsigned int)1 << 4);
  usbotghs_ctx.dev.irqs[0].posthook.action[3].__anonCompField2.and.mode = (unsigned char)1;
  usbotghs_ctx.dev.gpio_num = (unsigned char)13;
  usbotghs_ctx.dev.gpios[0].mask = (enum __anonenum_gpio_mask_t_18)((
                                                                    (
                                                                    (
                                                                    GPIO_MASK_SET_MODE | GPIO_MASK_SET_PUPD) | GPIO_MASK_SET_TYPE) | GPIO_MASK_SET_SPEED) | GPIO_MASK_SET_AFR);
  usbotghs_ctx.dev.gpios[0].kref.__anonCompField1.port = (unsigned char)usb_otg_hs_dev_infos_4.gpios[0].port;
  usbotghs_ctx.dev.gpios[0].kref.__anonCompField1.pin = (unsigned char)usb_otg_hs_dev_infos_4.gpios[0].pin;
  usbotghs_ctx.dev.gpios[0].mode = GPIO_PIN_ALTERNATE_MODE;
  usbotghs_ctx.dev.gpios[0].pupd = GPIO_NOPULL;
  usbotghs_ctx.dev.gpios[0].type = GPIO_PIN_OTYPER_PP;
  usbotghs_ctx.dev.gpios[0].speed = GPIO_PIN_VERY_HIGH_SPEED;
  usbotghs_ctx.dev.gpios[0].afr = (unsigned int)GPIO_AF_AF10;
  usbotghs_ctx.dev.gpios[1].mask = (enum __anonenum_gpio_mask_t_18)((
                                                                    (
                                                                    (
                                                                    GPIO_MASK_SET_MODE | GPIO_MASK_SET_PUPD) | GPIO_MASK_SET_TYPE) | GPIO_MASK_SET_SPEED) | GPIO_MASK_SET_AFR);
  usbotghs_ctx.dev.gpios[1].kref.__anonCompField1.port = (unsigned char)usb_otg_hs_dev_infos_4.gpios[1].port;
  usbotghs_ctx.dev.gpios[1].kref.__anonCompField1.pin = (unsigned char)usb_otg_hs_dev_infos_4.gpios[1].pin;
  usbotghs_ctx.dev.gpios[1].mode = GPIO_PIN_ALTERNATE_MODE;
  usbotghs_ctx.dev.gpios[1].pupd = GPIO_NOPULL;
  usbotghs_ctx.dev.gpios[1].type = GPIO_PIN_OTYPER_PP;
  usbotghs_ctx.dev.gpios[1].speed = GPIO_PIN_VERY_HIGH_SPEED;
  usbotghs_ctx.dev.gpios[1].afr = (unsigned int)GPIO_AF_AF10;
  {
    uint8_t i = (unsigned char)2;
    while ((int)i <= 8) {
      usbotghs_ctx.dev.gpios[i].mask = (enum __anonenum_gpio_mask_t_18)(
      (((GPIO_MASK_SET_MODE | GPIO_MASK_SET_PUPD) | GPIO_MASK_SET_TYPE) | GPIO_MASK_SET_SPEED) | GPIO_MASK_SET_AFR);
      usbotghs_ctx.dev.gpios[i].kref.__anonCompField1.port = (unsigned char)usb_otg_hs_dev_infos_4.gpios[i].port;
      usbotghs_ctx.dev.gpios[i].kref.__anonCompField1.pin = (unsigned char)usb_otg_hs_dev_infos_4.gpios[i].pin;
      usbotghs_ctx.dev.gpios[i].mode = GPIO_PIN_ALTERNATE_MODE;
      usbotghs_ctx.dev.gpios[i].pupd = GPIO_NOPULL;
      usbotghs_ctx.dev.gpios[i].type = GPIO_PIN_OTYPER_PP;
      usbotghs_ctx.dev.gpios[i].speed = GPIO_PIN_VERY_HIGH_SPEED;
      usbotghs_ctx.dev.gpios[i].afr = (unsigned int)GPIO_AF_AF10;
      i = (uint8_t)((int)i + 1);
    }
  }
  usbotghs_ctx.dev.gpios[9].mask = (enum __anonenum_gpio_mask_t_18)((
                                                                    (
                                                                    (
                                                                    GPIO_MASK_SET_MODE | GPIO_MASK_SET_PUPD) | GPIO_MASK_SET_TYPE) | GPIO_MASK_SET_SPEED) | GPIO_MASK_SET_AFR);
  usbotghs_ctx.dev.gpios[9].kref.__anonCompField1.port = (unsigned char)usb_otg_hs_dev_infos_4.gpios[9].port;
  usbotghs_ctx.dev.gpios[9].kref.__anonCompField1.pin = (unsigned char)usb_otg_hs_dev_infos_4.gpios[9].pin;
  usbotghs_ctx.dev.gpios[9].mode = GPIO_PIN_ALTERNATE_MODE;
  usbotghs_ctx.dev.gpios[9].pupd = GPIO_NOPULL;
  usbotghs_ctx.dev.gpios[9].type = GPIO_PIN_OTYPER_PP;
  usbotghs_ctx.dev.gpios[9].speed = GPIO_PIN_VERY_HIGH_SPEED;
  usbotghs_ctx.dev.gpios[9].afr = (unsigned int)GPIO_AF_AF10;
  usbotghs_ctx.dev.gpios[10].mask = (enum __anonenum_gpio_mask_t_18)(
  (((GPIO_MASK_SET_MODE | GPIO_MASK_SET_PUPD) | GPIO_MASK_SET_TYPE) | GPIO_MASK_SET_SPEED) | GPIO_MASK_SET_AFR);
  usbotghs_ctx.dev.gpios[10].kref.__anonCompField1.port = (unsigned char)usb_otg_hs_dev_infos_4.gpios[10].port;
  usbotghs_ctx.dev.gpios[10].kref.__anonCompField1.pin = (unsigned char)usb_otg_hs_dev_infos_4.gpios[10].pin;
  usbotghs_ctx.dev.gpios[10].mode = GPIO_PIN_ALTERNATE_MODE;
  usbotghs_ctx.dev.gpios[10].pupd = GPIO_NOPULL;
  usbotghs_ctx.dev.gpios[10].type = GPIO_PIN_OTYPER_PP;
  usbotghs_ctx.dev.gpios[10].speed = GPIO_PIN_VERY_HIGH_SPEED;
  usbotghs_ctx.dev.gpios[10].afr = (unsigned int)GPIO_AF_AF10;
  usbotghs_ctx.dev.gpios[11].mask = (enum __anonenum_gpio_mask_t_18)(
  (((GPIO_MASK_SET_MODE | GPIO_MASK_SET_PUPD) | GPIO_MASK_SET_TYPE) | GPIO_MASK_SET_SPEED) | GPIO_MASK_SET_AFR);
  usbotghs_ctx.dev.gpios[11].kref.__anonCompField1.port = (unsigned char)usb_otg_hs_dev_infos_4.gpios[11].port;
  usbotghs_ctx.dev.gpios[11].kref.__anonCompField1.pin = (unsigned char)usb_otg_hs_dev_infos_4.gpios[11].pin;
  usbotghs_ctx.dev.gpios[11].mode = GPIO_PIN_ALTERNATE_MODE;
  usbotghs_ctx.dev.gpios[11].pupd = GPIO_NOPULL;
  usbotghs_ctx.dev.gpios[11].type = GPIO_PIN_OTYPER_PP;
  usbotghs_ctx.dev.gpios[11].speed = GPIO_PIN_VERY_HIGH_SPEED;
  usbotghs_ctx.dev.gpios[11].afr = (unsigned int)GPIO_AF_AF10;
  usbotghs_ctx.dev.gpios[12].mask = (enum __anonenum_gpio_mask_t_18)(
  (((GPIO_MASK_SET_MODE | GPIO_MASK_SET_PUPD) | GPIO_MASK_SET_TYPE) | GPIO_MASK_SET_SPEED) | GPIO_MASK_SET_AFR);
  usbotghs_ctx.dev.gpios[12].kref.__anonCompField1.port = (unsigned char)usb_otg_hs_dev_infos_4.gpios[12].port;
  usbotghs_ctx.dev.gpios[12].kref.__anonCompField1.pin = (unsigned char)usb_otg_hs_dev_infos_4.gpios[12].pin;
  usbotghs_ctx.dev.gpios[12].mode = GPIO_PIN_OUTPUT_MODE;
  usbotghs_ctx.dev.gpios[12].pupd = GPIO_PULLUP;
  usbotghs_ctx.dev.gpios[12].type = GPIO_PIN_OTYPER_PP;
  usbotghs_ctx.dev.gpios[12].speed = GPIO_PIN_VERY_HIGH_SPEED;
  usbotghs_ctx.dev.gpios[12].afr = (unsigned int)GPIO_AF_AF10;
  tmp_0 = sys_init_INIT_DEVACCESS((unsigned int)INIT_DEVACCESS,
                                  (device_t const *)(& usbotghs_ctx.dev),
                                  (int *)(& usbotghs_ctx.dev_desc));
  ;
  if ((ret == tmp_0) != SYS_E_DONE) {
    __retres = MBED_ERROR_UNKNOWN;
    goto return_label;
  }
  __retres = MBED_ERROR_NONE;
  return_label: return __retres;
}

mbed_error_t usbotghs_configure(usbotghs_dev_mode_t mode,
                                mbed_error_t (*ieph)(uint32_t dev_id,
                                                     uint32_t size,
                                                     uint8_t ep),
                                mbed_error_t (*oeph)(uint32_t dev_id,
                                                     uint32_t size,
                                                     uint8_t ep))
{
  e_syscall_ret tmp;
  mbed_error_t errcode = MBED_ERROR_NONE;
  tmp = sys_cfg_CFG_DEV_MAP((unsigned int)CFG_DEV_MAP,
                            (unsigned int)usbotghs_ctx.dev_desc);
  if (tmp) {
    errcode = MBED_ERROR_NOMEM;
    goto err;
  }
  errcode = usbotghs_ulpi_reset();
  if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
  usbotghs_ctx.mode = mode;
  errcode = usbotghs_initialize_core(mode);
  if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
  switch (mode) {
    case (usbotghs_dev_mode_t)USBOTGHS_MODE_HOST:
    {
      errcode = usbotghs_initialize_host();
      if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
      break;
    }
    case (usbotghs_dev_mode_t)USBOTGHS_MODE_DEVICE:
    {
      errcode = usbotghs_initialize_device();
      if (errcode != (unsigned int)MBED_ERROR_NONE) goto err;
      break;
    }
    default: errcode = MBED_ERROR_INVPARAM;
    goto err;
    break;
  }
  usbotghs_ctx.fifo_idx = (unsigned short)0;
  usbotghs_ctx.in_eps[0].id = (unsigned char)0;
  usbotghs_ctx.in_eps[0].configured = true;
  usbotghs_ctx.in_eps[0].mpsize = (unsigned short)USBOTG_HS_EPx_MPSIZE_64BYTES;
  usbotghs_ctx.in_eps[0].type = USBOTG_HS_EP_TYPE_CONTROL;
  usbotghs_ctx.in_eps[0].state = USBOTG_HS_EP_STATE_IDLE;
  usbotghs_ctx.in_eps[0].handler = ieph;
  usbotghs_ctx.in_eps[0].fifo = (uint8_t volatile *)0;
  usbotghs_ctx.in_eps[0].fifo_idx = (unsigned int)0;
  usbotghs_ctx.in_eps[0].fifo_size = (unsigned int)0;
  usbotghs_ctx.in_eps[0].fifo_lck = false;
  usbotghs_ctx.in_eps[0].dir = USBOTG_HS_EP_DIR_IN;
  if (mode == (unsigned int)USBOTGHS_MODE_DEVICE) usbotghs_ctx.in_eps[0].core_txfifo_empty = true;
  usbotghs_ctx.out_eps[0].id = (unsigned char)0;
  usbotghs_ctx.out_eps[0].configured = true;
  usbotghs_ctx.out_eps[0].mpsize = (unsigned short)USBOTG_HS_EPx_MPSIZE_64BYTES;
  usbotghs_ctx.out_eps[0].type = USBOTG_HS_EP_TYPE_CONTROL;
  usbotghs_ctx.out_eps[0].state = USBOTG_HS_EP_STATE_IDLE;
  usbotghs_ctx.out_eps[0].handler = oeph;
  usbotghs_ctx.out_eps[0].dir = USBOTG_HS_EP_DIR_OUT;
  usbotghs_ctx.out_eps[0].fifo = (uint8_t volatile *)0;
  usbotghs_ctx.out_eps[0].fifo_idx = (unsigned int)0;
  usbotghs_ctx.out_eps[0].fifo_size = (unsigned int)0;
  usbotghs_ctx.in_eps[0].fifo_lck = false;
  usbotghs_ctx.speed = USBOTG_HS_SPEED_HS;
  err: ;
  return errcode;
}

uint32_t usbotghs_get_ep_mpsize(void)
{
  uint32_t __retres;
  __retres = (unsigned int)512;
  return __retres;
}

mbed_error_t usbotghs_send_data(uint8_t *src, uint32_t size, uint8_t ep_id)
{
  mbed_error_t __retres;
  int tmp_0;
  uint32_t tmp_12;
  uint32_t packet_count = (unsigned int)0;
  mbed_error_t errcode = MBED_ERROR_NONE;
  uint32_t fifo_size = (unsigned int)0;
  usbotghs_context_t *ctx = usbotghs_get_context();
  usbotghs_ep_t *ep = (usbotghs_ep_t *)0;
  ep = & ctx->in_eps[ep_id];
  if (! ep->configured) {
    errcode = MBED_ERROR_INVSTATE;
    goto err_init;
  }
  fifo_size = (unsigned int)512;
  errcode = usbotghs_set_xmit_fifo(src,size,ep_id);
  if (errcode != (unsigned int)MBED_ERROR_NONE) goto err_init;
  uint32_t residual_size = size;
  if (size % (unsigned int)ep->mpsize) tmp_0 = 1; else tmp_0 = 0;
  packet_count = size / (uint32_t)ep->mpsize + (uint32_t)tmp_0;
  if ((int)ep_id > 0) goto _LOR;
  else 
    if (size < (uint32_t)ep->mpsize) {
      _LOR:
      {
        unsigned int tmp_1;
        unsigned int tmp_2;
        if ((int)ep_id > 0) tmp_1 = (unsigned int)0x3ff << 19;
        else tmp_1 = (unsigned int)0x3 << 19;
        ;
        ;
        set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x910) + 
                                              (int)ep_id * 0x20),
                        packet_count,tmp_1,(unsigned char)19);
        if ((int)ep_id > 0) tmp_2 = (unsigned int)0x7ffff << 0;
        else tmp_2 = (unsigned int)0x7f << 0;
        ;
        ;
        set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x910) + 
                                              (int)ep_id * 0x20),size,tmp_2,
                        (unsigned char)0);
      }
    }
    else {
      unsigned int tmp_3;
      unsigned int tmp_4;
      if ((int)ep_id > 0) tmp_3 = (unsigned int)0x3ff << 19;
      else tmp_3 = (unsigned int)0x3 << 19;
      ;
      set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x910) + (int)ep_id * 0x20),
                      (unsigned int)1,tmp_3,(unsigned char)19);
      if ((int)ep_id > 0) tmp_4 = (unsigned int)0x7ffff << 0;
      else tmp_4 = (unsigned int)0x7f << 0;
      ;
      ;
      set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x910) + (int)ep_id * 0x20),
                      (unsigned int)ep->mpsize,tmp_4,(unsigned char)0);
    }
  ep->state = USBOTG_HS_EP_STATE_DATA_IN_WIP;
  set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep_id * 0x20),
                 ((unsigned int)1 << 26) | ((unsigned int)1 << 31));
  if ((int)ep_id == 0) 
    if (size > (uint32_t)ep->mpsize) {
      while (1) {
        uint32_t tmp_6;
        tmp_6 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                                (0x40040000 + 0x918) + (int)ep_id * 0x20)),
                                (unsigned int)0xffff << 0,(unsigned char)0);
        ;
        if (! (tmp_6 < (uint32_t)((int)ep->mpsize / 4))) break;
        {
          uint32_t tmp_5;
          tmp_5 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                                  0x40040000 + 0x808)),(unsigned int)1 << 0,
                                  (unsigned char)0);
          if (tmp_5) {
            errcode = MBED_ERROR_BUSY;
            goto err;
          }
        }
      }
      ep->state = USBOTG_HS_EP_STATE_DATA_IN;
      usbotghs_write_epx_fifo((unsigned int)ep->mpsize,ep);
      goto err;
    }
  while (residual_size >= fifo_size) {
    while (1) {
      uint32_t tmp_8;
      tmp_8 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                              (0x40040000 + 0x918) + (int)ep_id * 0x20)),
                              (unsigned int)0xffff << 0,(unsigned char)0);
      ;
      if (! (tmp_8 < fifo_size / (uint32_t)4)) break;
      {
        uint32_t tmp_7;
        tmp_7 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                                0x40040000 + 0x808)),(unsigned int)1 << 0,
                                (unsigned char)0);
        if (tmp_7) {
          errcode = MBED_ERROR_BUSY;
          goto err;
        }
      }
    }
    if (residual_size == fifo_size) ep->state = USBOTG_HS_EP_STATE_DATA_IN;
    usbotghs_write_epx_fifo(fifo_size,ep);
    residual_size -= fifo_size;
  }
  if (residual_size > (uint32_t)0) {
    while (1) {
      uint32_t tmp_10;
      int tmp_11;
      tmp_10 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                               (0x40040000 + 0x918) + (int)ep_id * 0x20)),
                               (unsigned int)0xffff << 0,(unsigned char)0);
      if (residual_size & (unsigned int)3) tmp_11 = 1; else tmp_11 = 0;
      ;
      if (! (tmp_10 < residual_size / (uint32_t)4 + (uint32_t)tmp_11)) 
        break;
      {
        uint32_t tmp_9;
        tmp_9 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                                0x40040000 + 0x808)),(unsigned int)1 << 0,
                                (unsigned char)0);
        if (tmp_9) {
          errcode = MBED_ERROR_BUSY;
          goto err;
        }
      }
    }
    ep->state = USBOTG_HS_EP_STATE_DATA_IN;
    usbotghs_write_epx_fifo(residual_size,ep);
    residual_size = (unsigned int)0;
  }
  tmp_12 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                           0x40040000 + 0x808)),(unsigned int)1 << 0,
                           (unsigned char)0);
  if (tmp_12) {
    errcode = MBED_ERROR_BUSY;
    goto err;
  }
  __retres = errcode;
  goto return_label;
  err: ep->state = USBOTG_HS_EP_STATE_IDLE;
  err_init: ;
  __retres = errcode;
  return_label: return __retres;
}

mbed_error_t usbotghs_send_zlp(uint8_t ep_id)
{
  unsigned int tmp_2;
  unsigned int tmp_3;
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_context_t *ctx = usbotghs_get_context();
  usbotghs_ep_t *ep = (usbotghs_ep_t *)0;
  ep = & ctx->in_eps[ep_id];
  if (! ep->configured) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  while (1) {
    uint32_t tmp_1;
    tmp_1 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                            (0x40040000 + 0x918) + (int)ep_id * 0x20)),
                            (unsigned int)0xffff << 0,(unsigned char)0);
    if (! (tmp_1 < (uint32_t)(512 / 4))) break;
    {
      uint32_t tmp_0;
      tmp_0 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                              0x40040000 + 0x808)),(unsigned int)1 << 0,
                              (unsigned char)0);
      if (tmp_0) {
        errcode = MBED_ERROR_BUSY;
        goto err;
      }
    }
  }
  if ((int)ep_id > 0) tmp_2 = (unsigned int)0x3ff << 19;
  else tmp_2 = (unsigned int)0x3 << 19;
  ;
  set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x910) + (int)ep_id * 0x20),
                  (unsigned int)1,tmp_2,(unsigned char)19);
  if ((int)ep_id > 0) tmp_3 = (unsigned int)0x7ffff << 0;
  else tmp_3 = (unsigned int)0x7f << 0;
  ;
  set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x910) + (int)ep_id * 0x20),
                  (unsigned int)0,tmp_3,(unsigned char)0);
  set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep_id * 0x20),
                 ((unsigned int)1 << 26) | ((unsigned int)1 << 31));
  err: ;
  return errcode;
}

mbed_error_t usbotghs_global_stall(void)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  return errcode;
}

mbed_error_t usbotghs_endpoint_set_nak(uint8_t ep_id, usbotghs_ep_dir_t dir)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_context_t *ctx = usbotghs_get_context();
  uint32_t count = (unsigned int)0;
  if (ctx == (usbotghs_context_t *)0) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  switch (dir) {
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_IN: ;
    if ((int)ep_id >= 8) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    if (ctx->in_eps[ep_id].configured == (unsigned int)false) {
      errcode = MBED_ERROR_INVSTATE;
      goto err;
    }
    while (1) {
      uint32_t tmp_0;
      tmp_0 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                              (0x40040000 + 0x900) + (int)ep_id * 0x20)),
                              (unsigned int)1 << 31,(unsigned char)31);
      if (! tmp_0) break;
      count ++;
      if (count > (uint32_t)50) {
        errcode = MBED_ERROR_BUSY;
        goto err;
      }
    }
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep_id * 0x20),
                   (unsigned int)1 << 27);
    if ((int)ep_id == 0) break;
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_OUT: ;
    if ((int)ep_id >= 3) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    if (ctx->out_eps[ep_id].configured == (unsigned int)false) {
      errcode = MBED_ERROR_INVSTATE;
      goto err;
    }
    while (1) {
      uint32_t tmp_1;
      tmp_1 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                              (0x40040000 + 0xb00) + (int)ep_id * 0x20)),
                              (unsigned int)1 << 31,(unsigned char)31);
      if (! tmp_1) break;
      count ++;
      if (count > (uint32_t)50) {
        errcode = MBED_ERROR_BUSY;
        goto err;
      }
    }
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0xb00) + (int)ep_id * 0x20),
                   (unsigned int)1 << 27);
    break;
    default: errcode = MBED_ERROR_INVPARAM;
    goto err;
  }
  err: ;
  return errcode;
}

mbed_error_t usbotghs_endpoint_clear_nak(uint8_t ep_id, usbotghs_ep_dir_t dir)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_context_t *ctx = usbotghs_get_context();
  if (ctx == (usbotghs_context_t *)0) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  switch (dir) {
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_IN: ;
    if ((int)ep_id >= 8) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    if (ctx->in_eps[ep_id].configured == (unsigned int)false) {
      errcode = MBED_ERROR_INVSTATE;
      goto err;
    }
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep_id * 0x20),
                   (unsigned int)1 << 26);
    if ((int)ep_id == 0) break;
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_OUT: ;
    if ((int)ep_id >= 3) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    if (ctx->out_eps[ep_id].configured == (unsigned int)false) {
      errcode = MBED_ERROR_INVSTATE;
      goto err;
    }
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0xb00) + (int)ep_id * 0x20),
                   (unsigned int)1 << 26);
    break;
    default: ;
    errcode = MBED_ERROR_INVPARAM;
    goto err;
  }
  err: ;
  return errcode;
}

mbed_error_t usbotghs_global_stall_clear(void)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  return errcode;
}

mbed_error_t usbotghs_endpoint_stall(uint8_t ep_id, usbotghs_ep_dir_t dir)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_context_t *ctx = usbotghs_get_context();
  uint32_t count = (unsigned int)0;
  if (ctx == (usbotghs_context_t *)0) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  switch (dir) {
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_IN: ;
    if ((int)ep_id >= 8) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    if (ctx->in_eps[ep_id].configured == (unsigned int)false) {
      errcode = MBED_ERROR_INVSTATE;
      goto err;
    }
    while (1) {
      uint32_t tmp_0;
      tmp_0 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                              (0x40040000 + 0x900) + (int)ep_id * 0x20)),
                              (unsigned int)1 << 31,(unsigned char)31);
      if (! tmp_0) break;
      count ++;
      if (count > (uint32_t)50) {
        errcode = MBED_ERROR_BUSY;
        goto err;
      }
      continue;
    }
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep_id * 0x20),
                   (unsigned int)1 << 30);
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep_id * 0x20),
                   (unsigned int)1 << 21);
    break;
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_OUT: ;
    if ((int)ep_id >= 3) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    if (ctx->out_eps[ep_id].configured == (unsigned int)false) {
      errcode = MBED_ERROR_INVSTATE;
      goto err;
    }
    while (1) {
      uint32_t tmp_1;
      tmp_1 = get_reg_value_4((uint32_t const volatile *)((uint32_t volatile *)(
                              (0x40040000 + 0xb00) + (int)ep_id * 0x20)),
                              (unsigned int)1 << 31,(unsigned char)31);
      if (! tmp_1) break;
      count ++;
      if (count > (uint32_t)50) {
        errcode = MBED_ERROR_BUSY;
        goto err;
      }
    }
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0xb00) + (int)ep_id * 0x20),
                   (unsigned int)1 << 30);
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0xb00) + (int)ep_id * 0x20),
                   (unsigned int)1 << 21);
    break;
    default: errcode = MBED_ERROR_INVPARAM;
    goto err;
  }
  err: ;
  return errcode;
}

mbed_error_t usbotghs_endpoint_stall_clear(uint8_t ep, usbotghs_ep_dir_t dir)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  ep = ep;
  dir = dir;
  return errcode;
}

mbed_error_t usbotghs_configure_endpoint(uint8_t ep, usbotghs_ep_type_t type,
                                         usbotghs_ep_dir_t dir,
                                         usbotghs_epx_mpsize_t mpsize,
                                         usbotghs_ep_toggle_t dtoggle,
                                         mbed_error_t (*handler)(uint32_t dev_id,
                                                                 uint32_t size,
                                                                 uint8_t ep))
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_context_t *ctx = usbotghs_get_context();
  if (ctx == (usbotghs_context_t *)0) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  switch (dir) {
    unsigned int tmp_0;
    unsigned int tmp_1;
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_IN: ;
    ctx->in_eps[ep].id = ep;
    ctx->in_eps[ep].dir = dir;
    ctx->in_eps[ep].configured = true;
    ctx->in_eps[ep].mpsize = (unsigned short)mpsize;
    ctx->in_eps[ep].type = type;
    ctx->in_eps[ep].state = USBOTG_HS_EP_STATE_IDLE;
    ctx->in_eps[ep].handler = handler;
    ctx->out_eps[ep].configured = false;
    set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep * 0x20),
                    type,(unsigned int)0x3 << 18,(unsigned char)18);
    if ((int)ep > 0) tmp_0 = (unsigned int)0x7ff << 0;
    else tmp_0 = (unsigned int)0x3 << 0;
    ;
    ;
    set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep * 0x20),
                    mpsize,tmp_0,(unsigned char)0);
    if (type == (unsigned int)USBOTG_HS_EP_TYPE_BULK) goto _LOR;
    else 
      if (type == (unsigned int)USBOTG_HS_EP_TYPE_INT) _LOR:
                                                       set_reg_value_4
                                                       ((uint32_t volatile *)(
                                                        (0x40040000 + 0x900) + 
                                                        (int)ep * 0x20),
                                                        dtoggle,
                                                        (unsigned int)1 << 28,
                                                        (unsigned char)28);
    usbotghs_reset_epx_fifo(& ctx->in_eps[ep]);
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep * 0x20),
                   (unsigned int)1 << 15);
    set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep * 0x20),
                    (unsigned int)ep,(unsigned int)1 << 26,(unsigned char)26);
    set_reg_bits_4((uint32_t volatile *)(0x40040000 + 0x81C),
                   (unsigned int)1 << (int)ep);
    break;
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_OUT: ;
    ctx->out_eps[ep].id = ep;
    ctx->out_eps[ep].dir = dir;
    ctx->out_eps[ep].configured = true;
    ctx->out_eps[ep].mpsize = (unsigned short)mpsize;
    ctx->out_eps[ep].type = type;
    ctx->out_eps[ep].state = USBOTG_HS_EP_STATE_IDLE;
    ctx->out_eps[ep].handler = handler;
    ctx->in_eps[ep].configured = false;
    if ((int)ep > 0) tmp_1 = (unsigned int)0x7ff << 0;
    else tmp_1 = (unsigned int)0x3 << 0;
    ;
    ;
    set_reg_value_4((uint32_t volatile *)((0x40040000 + 0xb00) + (int)ep * 0x20),
                    mpsize,tmp_1,(unsigned char)0);
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0xb00) + (int)ep * 0x20),
                   (unsigned int)1 << 15);
    if (type == (unsigned int)USBOTG_HS_EP_TYPE_BULK) goto _LOR_0;
    else 
      if (type == (unsigned int)USBOTG_HS_EP_TYPE_INT) _LOR_0:
                                                       set_reg_value_4
                                                       ((uint32_t volatile *)(
                                                        (0x40040000 + 0xb00) + 
                                                        (int)ep * 0x20),
                                                        dtoggle,
                                                        (unsigned int)1 << 28,
                                                        (unsigned char)28);
    set_reg_value_4((uint32_t volatile *)((0x40040000 + 0xb00) + (int)ep * 0x20),
                    type,(unsigned int)0x3 << 18,(unsigned char)18);
    usbotghs_reset_epx_fifo(& ctx->out_eps[ep]);
    set_reg_bits_4((uint32_t volatile *)(0x40040000 + 0x81C),
                   (unsigned int)1 << ((int)ep + 16));
    break;
  }
  err: ;
  return errcode;
}

mbed_error_t usbotghs_deconfigure_endpoint(uint8_t ep)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_context_t *ctx = usbotghs_get_context();
  if (ctx == (usbotghs_context_t *)0) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  clear_reg_bits_4((uint32_t volatile *)(0x40040000 + 0x018),
                   ((unsigned int)1 << 5) | ((unsigned int)1 << 4));
  if (ctx->in_eps[ep].configured == (unsigned int)true) clear_reg_bits_4
                                                        ((uint32_t volatile *)(
                                                         (0x40040000 + 0x900) + 
                                                         (int)ep * 0x20),
                                                         (unsigned int)1 << 31);
  if (ctx->out_eps[ep].configured == (unsigned int)true) clear_reg_bits_4
                                                         ((uint32_t volatile *)(
                                                          (0x40040000 + 0xb00) + 
                                                          (int)ep * 0x20),
                                                          (unsigned int)1 << 31);
  set_reg_bits_4((uint32_t volatile *)(0x40040000 + 0x018),
                 ((unsigned int)1 << 5) | ((unsigned int)1 << 4));
  err: ;
  return errcode;
}

mbed_error_t usbotghs_activate_endpoint(uint8_t ep_id, usbotghs_ep_dir_t dir)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_context_t *ctx = usbotghs_get_context();
  if (ctx == (usbotghs_context_t *)0) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  if (dir == (unsigned int)USBOTG_HS_EP_DIR_IN) set_reg_bits_4((uint32_t volatile *)(
                                                               (0x40040000 + 0x900) + 
                                                               (int)ep_id * 0x20),
                                                               (unsigned int)1 << 31);
  else {
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0xb00) + (int)ep_id * 0x20),
                   (unsigned int)1 << 26);
    set_reg_bits_4((uint32_t volatile *)((0x40040000 + 0xb00) + (int)ep_id * 0x20),
                   (unsigned int)1 << 31);
  }
  err: ;
  return errcode;
}

mbed_error_t usbotghs_deactivate_endpoint(uint8_t ep, usbotghs_ep_dir_t dir)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_context_t *ctx = usbotghs_get_context();
  if (ctx == (usbotghs_context_t *)0) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  clear_reg_bits_4((uint32_t volatile *)(0x40040000 + 0x018),
                   ((unsigned int)1 << 5) | ((unsigned int)1 << 4));
  if (dir == (unsigned int)USBOTG_HS_EP_DIR_IN) clear_reg_bits_4((uint32_t volatile *)(
                                                                 (0x40040000 + 0x900) + 
                                                                 (int)ep * 0x20),
                                                                 (unsigned int)1 << 31);
  else clear_reg_bits_4((uint32_t volatile *)((0x40040000 + 0xb00) + 
                                              (int)ep * 0x20),
                        (unsigned int)1 << 31);
  set_reg_bits_4((uint32_t volatile *)(0x40040000 + 0x018),
                 ((unsigned int)1 << 5) | ((unsigned int)1 << 4));
  err: ;
  return errcode;
}

mbed_error_t usbotghs_enpoint_nak(uint8_t ep)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  ep = ep;
  return errcode;
}

mbed_error_t usbotghs_enpoint_nak_clear(uint8_t ep)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  ep = ep;
  return errcode;
}

/*@ assigns \result;
    assigns \result
      \from (indirect: *(fmt + (0 ..))), (indirect: param1),
            (indirect: param0);
 */
int printf_va_5(char const *fmt, int param0, int param1);

mbed_error_t usbotghs_endpoint_disable(uint8_t ep_id, usbotghs_ep_dir_t dir)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_ep_t *ep = (usbotghs_ep_t *)0;
  printf_va_5("[USBOTGHS] disable EP %d: dir %d\n",(int)ep_id,(int)dir);
  usbotghs_context_t *ctx = usbotghs_get_context();
  if (ctx == (usbotghs_context_t *)0) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  switch (dir) {
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_IN: ;
    if ((int)ep_id > 8) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    ep = & ctx->in_eps[ep_id];
    break;
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_OUT: ;
    if ((int)ep_id > 3) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    ep = & ctx->in_eps[ep_id];
    break;
    default: errcode = MBED_ERROR_INVPARAM;
    goto err;
    break;
  }
  set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep_id * 0x20),
                  (unsigned int)0x1,(unsigned int)1 << 30,(unsigned char)30);
  err: ;
  return errcode;
}

/*@ assigns \result;
    assigns \result
      \from (indirect: *(fmt + (0 ..))), (indirect: param1),
            (indirect: param0);
 */
int printf_va_6(char const *fmt, int param0, int param1);

mbed_error_t usbotghs_endpoint_enable(uint8_t ep_id, usbotghs_ep_dir_t dir)
{
  mbed_error_t errcode = MBED_ERROR_NONE;
  usbotghs_ep_t *ep = (usbotghs_ep_t *)0;
  printf_va_6("[USBOTGHS] enable EP %d: dir %d\n",(int)ep_id,(int)dir);
  usbotghs_context_t *ctx = usbotghs_get_context();
  if (ctx == (usbotghs_context_t *)0) {
    errcode = MBED_ERROR_INVSTATE;
    goto err;
  }
  switch (dir) {
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_IN: ;
    if ((int)ep_id > 8) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    ep = & ctx->in_eps[ep_id];
    break;
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_OUT: ;
    if ((int)ep_id > 3) {
      errcode = MBED_ERROR_INVPARAM;
      goto err;
    }
    ep = & ctx->in_eps[ep_id];
    break;
    default: errcode = MBED_ERROR_INVPARAM;
    goto err;
    break;
  }
  set_reg_value_4((uint32_t volatile *)((0x40040000 + 0x900) + (int)ep_id * 0x20),
                  (unsigned int)0x0,(unsigned int)1 << 30,(unsigned char)30);
  err: ;
  return errcode;
}

void usbotghs_set_address(uint16_t addr)
{
  set_reg_value_4((uint32_t volatile *)(0x40040000 + 0x800),
                  (unsigned int)addr,(unsigned int)0x7f << 4,
                  (unsigned char)4);
  return;
}

usbotghs_ep_state_t usbotghs_get_ep_state(uint8_t epnum,
                                          usbotghs_ep_dir_t dir)
{
  usbotghs_ep_state_t __retres;
  if (dir == (unsigned int)USBOTG_HS_EP_DIR_IN) 
    if ((int)epnum >= 8) {
      __retres = USBOTG_HS_EP_STATE_INVALID;
      goto return_label;
    }
  if (dir == (unsigned int)USBOTG_HS_EP_DIR_OUT) 
    if ((int)epnum >= 3) {
      __retres = USBOTG_HS_EP_STATE_INVALID;
      goto return_label;
    }
  switch (dir) {
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_IN: ;
    __retres = usbotghs_ctx.in_eps[epnum].state;
    goto return_label;
    break;
    case (usbotghs_ep_dir_t)USBOTG_HS_EP_DIR_OUT: ;
    __retres = usbotghs_ctx.out_eps[epnum].state;
    goto return_label;
    break;
    default: __retres = USBOTG_HS_EP_STATE_INVALID;
    goto return_label;
    break;
  }
  __retres = USBOTG_HS_EP_STATE_INVALID;
  return_label: return __retres;
}

usbotghs_port_speed_t usbotghs_get_speed(void)
{
  usbotghs_port_speed_t __retres;
  __retres = USBOTG_HS_PORT_HIGHSPEED;
  return __retres;
}

mbed_error_t usb_backend_drv_configure(usb_backend_drv_mode_t mode,
                                       mbed_error_t (*ieph)(uint32_t dev_id,
                                                            uint32_t size,
                                                            uint8_t ep),
                                       mbed_error_t (*oeph)(uint32_t dev_id,
                                                            uint32_t size,
                                                            uint8_t ep))
{
  mbed_error_t tmp;
  tmp = usbotghs_configure((enum __anonenum_usbotghs_dev_mode_t_58)mode,ieph,
                           oeph);
  return tmp;
}

mbed_error_t usb_backend_drv_declare(void)
{
  mbed_error_t tmp;
  tmp = usbotghs_declare();
  return tmp;
}

mbed_error_t usb_backend_drv_activate_endpoint(uint8_t id,
                                               usb_backend_drv_ep_dir_t dir)
{
  mbed_error_t tmp;
  tmp = usbotghs_activate_endpoint(id,
                                   (enum __anonenum_usbotghs_ep_dir_t_65)dir);
  return tmp;
}

mbed_error_t usb_backend_drv_configure_endpoint(uint8_t ep,
                                                usb_backend_drv_ep_type_t type,
                                                usb_backend_drv_ep_dir_t dir,
                                                usb_backend_drv_epx_mpsize_t mpsize,
                                                usb_backend_drv_ep_toggle_t dtoggle,
                                                mbed_error_t (*handler)
                                                (uint32_t dev_id,
                                                 uint32_t size, uint8_t ep))
{
  mbed_error_t tmp;
  tmp = usbotghs_configure_endpoint(ep,
                                    (enum __anonenum_usbotghs_ep_type_t_63)type,
                                    (enum __anonenum_usbotghs_ep_dir_t_65)dir,
                                    (enum __anonenum_usbotghs_epx_mpsize_t_61)mpsize,
                                    (enum __anonenum_usbotghs_ep_toggle_t_62)dtoggle,
                                    handler);
  return tmp;
}

mbed_error_t usb_backend_drv_get_ep_state(uint8_t epnum,
                                          usb_backend_drv_ep_dir_t dir)
{
  mbed_error_t __retres;
  usbotghs_ep_state_t tmp;
  tmp = usbotghs_get_ep_state(epnum,
                              (enum __anonenum_usbotghs_ep_dir_t_65)dir);
  __retres = (enum __anonenum_mbed_error_t_3)tmp;
  return __retres;
}

mbed_error_t usb_backend_drv_send_data(uint8_t *src, uint32_t size,
                                       uint8_t ep)
{
  mbed_error_t tmp;
  tmp = usbotghs_send_data(src,size,ep);
  return tmp;
}

mbed_error_t usb_backend_drv_send_zlp(uint8_t ep)
{
  mbed_error_t tmp;
  tmp = usbotghs_send_zlp(ep);
  return tmp;
}

void usb_backend_drv_set_address(uint16_t addr)
{
  usbotghs_set_address(addr);
  return;
}

mbed_error_t usb_backend_drv_ack(uint8_t ep_id, usb_backend_drv_ep_dir_t dir)
{
  mbed_error_t tmp;
  tmp = usbotghs_endpoint_clear_nak(ep_id,
                                    (enum __anonenum_usbotghs_ep_dir_t_65)dir);
  return tmp;
}

mbed_error_t usb_backend_drv_nak(uint8_t ep_id, usb_backend_drv_ep_dir_t dir)
{
  mbed_error_t tmp;
  tmp = usbotghs_endpoint_set_nak(ep_id,
                                  (enum __anonenum_usbotghs_ep_dir_t_65)dir);
  return tmp;
}

mbed_error_t usb_backend_drv_stall(uint8_t ep_id,
                                   usb_backend_drv_ep_dir_t dir)
{
  mbed_error_t tmp;
  tmp = usbotghs_endpoint_stall(ep_id,
                                (enum __anonenum_usbotghs_ep_dir_t_65)dir);
  return tmp;
}

mbed_error_t usb_backend_drv_endpoint_disable(uint8_t ep_id,
                                              usb_backend_drv_ep_dir_t dir)
{
  mbed_error_t tmp;
  tmp = usbotghs_endpoint_disable(ep_id,
                                  (enum __anonenum_usbotghs_ep_dir_t_65)dir);
  return tmp;
}

mbed_error_t usb_backend_drv_endpoint_enable(uint8_t ep_id,
                                             usb_backend_drv_ep_dir_t dir)
{
  mbed_error_t tmp;
  tmp = usbotghs_endpoint_enable(ep_id,
                                 (enum __anonenum_usbotghs_ep_dir_t_65)dir);
  return tmp;
}

uint32_t usb_backend_get_ep_mpsize(void)
{
  uint32_t tmp;
  tmp = usbotghs_get_ep_mpsize();
  return tmp;
}

usb_backend_drv_port_speed_t usb_backend_drv_get_speed(void)
{
  usb_backend_drv_port_speed_t __retres;
  usbotghs_port_speed_t tmp;
  tmp = usbotghs_get_speed();
  __retres = (enum __anonenum_usb_backend_drv_port_speed_t_49)tmp;
  return __retres;
}


